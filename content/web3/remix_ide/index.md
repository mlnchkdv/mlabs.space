---
weight: 1
title: Развертывание и взаимодействие со смарт-контрактами
description: Пошаговая инструкция по созданию смарт-контракта
author: MLabs
authorLink: null
date: 2024-09-05T14:48:57.920Z
lastmod: null
slug: solidity
categories:
  - WEB3
math: true
lightgallery: true
toc:
  auto: true
draft: false
---

### Умные контракты: пошаговое руководство

Умные контракты — это самоисполняемые контракты. Термин был введен Ником Сабо в 1994 году. Умные контракты существенно отличаются от традиционных программных приложений. После развертывания на блокчейне они становятся неизменяемыми. Именно благодаря платформе Ethereum термин "умный контракт" стал популярным и широко используемым. Основным языком программирования для написания умных контрактов на блокчейне Ethereum является **Solidity**. Этот язык ориентирован на контракты, что означает, что умные контракты содержат всю логику, необходимую для взаимодействия с блокчейном. 

Термин "умный" в умных контрактах означает, что контракт выполняется в зависимости от логических условий, а все узлы блокчейна хранят одинаковую копию этого контракта.

### Что такое Remix-IDE?

**Remix-IDE** — это интегрированная среда разработки (IDE) для создания умных контрактов на языке программирования Solidity. Remix-IDE можно использовать для написания, компиляции и отладки кода Solidity. Среда была разработана на языке JavaScript и поддерживает тестирование, отладку и развертывание умных контрактов, а также многие другие функции.

Доступ к Remix-IDE можно получить несколькими способами:

1. Онлайн-версия в любом браузере, перейдя по адресу: [https://remix.ethereum.org/](https://remix.ethereum.org/).
2. Установка на локальный компьютер с помощью этого [ссылки](https://github.com/ethereum/remix-ide).
3. Использование браузера для DApp приложений Mist.

### Начало работы

Данная инструкция поможет вам создать ваш первый умный контракт на языке Solidity с использованием Remix-IDE — браузерной среды разработки.

#### Шаг 1: Откройте Remix-IDE в браузере

Перейдите по ссылке: [https://remix.ethereum.org/](https://remix.ethereum.org/).

#### Шаг 2: Интерфейс Remix-IDE

После загрузки среды вы увидите следующий интерфейс:

![Интерфейс Remix-IDE](https://media.geeksforgeeks.org/wp-content/uploads/20200423221352/one12.png "Интерфейс Remix-IDE")

#### Шаг 3: Откройте файловый менеджер

Нажмите на иконку **“File Explorer”** в левой боковой панели (синяя стрелка на картинке выше).

#### Шаг 4: Настройка среды Solidity

Выберите **Solidity** в разделе Environment и нажмите на знак **\+** справа от браузера:

![Настройка среды Solidity](https://media.geeksforgeeks.org/wp-content/uploads/20200423221403/two10-300x284.png "Настройка среды Solidity")

#### Шаг 5: Создайте файл контракта

Введите имя файла **“HelloWorld.sol”** и добавьте в него следующий код:

```solidity
// Мой первый смарт-контракт
pragma solidity 0.8.0;

contract HelloWorld {
    function get() public pure returns (string memory) {
        return 'Hello Contracts';
    }
}
```

#### Шаг 6: Откройте раздел для компиляции

Нажмите на иконку под **“File Explorer”** как показано на изображении ниже:

![Раздел для компиляции](https://media.geeksforgeeks.org/wp-content/uploads/20200423221343/five2-300x292.png "Раздел для компиляции")

#### Шаг 7: Компиляция контракта

Выберите опцию **“Compile HelloWorld.sol”**. Оставьте остальные настройки по умолчанию.

#### Шаг 8: Развертывание контракта

После успешной компиляции нажмите на иконку под разделом **“Solidity Compiler”**, которая называется **“Deploy and run transactions”**. Вам будет представлена следующая страница:

![Развертывание контракта](https://media.geeksforgeeks.org/wp-content/uploads/20200423221354/seven1-238x300.png "Развертывание контракта")

Не меняя никаких значений, нажмите на кнопку **“Deploy”** для развертывания вашего умного контракта.

#### Шаг 9: Выполнение контракта

После развертывания вы найдете ваш контракт в разделе **“Deployed Contracts”**. Нажмите на стрелку рядом с вашим контрактом, и вы увидите кнопку **“get”** (так как наш контракт содержит функцию get). Нажмите на кнопку **“get”**, и вы получите результат: 

![Результат выполнения](https://media.geeksforgeeks.org/wp-content/uploads/20200423221349/nine1-300x150.png "Результат выполнения")

### Пример с геттерами и сеттерами

Теперь рассмотрим другой пример использования get и set методов для ввода строки пользователем и её отображения:

```solidity
pragma solidity 0.8.0;

contract HelloWorld {
    string userInput;

    function set(string memory finalValue) public {
        userInput = finalValue;
    }

    function get() public view returns (string memory) {
        return userInput;
    }
}
```

Для запуска этого примера выполните шаги до **Шага 9** предыдущего подхода, затем следуйте следующим шагам:

1. Нажмите стрелку в разделе **“Deployed Contracts”**. Откроется выпадающее меню, которое будет содержать два метода: **set** и **get**.

![Меню с методами](https://media.geeksforgeeks.org/wp-content/uploads/20230310204002/solidity_1.JPG "Меню с методами")

2. В поле рядом с методом **set** введите строку, которую хотите отобразить. После этого нажмите на кнопку **set**. После успешной транзакции нажмите на кнопку **get**, и введённая строка отобразится ниже:

![Результат работы сеттера и геттера](https://media.geeksforgeeks.org/wp-content/uploads/20230310204256/solidity_2.JPG "Результат работы сеттера и геттера")

### Улучшение навыков разработки смарт-контрактов: 

Теперь, когда вы создали свой первый смарт-контракт, давайте углубимся в некоторые более продвинутые аспекты разработки смарт-контрактов на Solidity. Далее мы рассмотрим:

1. Модификаторы доступа.
2. События и их использование.
3. Работа с массивами и структурами.
4. Оптимизация контрактов и работа с gas.
5. Безопасность смарт-контрактов.

### Модификаторы доступа

Модификаторы доступа позволяют контролировать, кто и когда может вызывать определенные функции контракта. Это важно для обеспечения безопасности контрактов. В Solidity вы можете использовать модификаторы, чтобы проверять условия перед выполнением функции.

> Модификаторы доступа в Solidity — это специальные конструкции, которые позволяют добавлять пред- и постусловия для выполнения функций. Их использование позволяет значительно улучшить безопасность и гибкость смарт-контрактов. Основное применение модификаторов заключается в проверке определённых условий перед выполнением функции (например, проверка прав доступа).
>
> Модификаторы часто используются для ограничения доступа к функциям, что особенно важно при работе с конфиденциальными данными или при выполнении критических операций, таких как передача прав собственности или управление активами.

Рассмотрим простой пример смарт-контракта с модификатором доступа (**onlyOwner**), который ограничивает выполнение определённых функций (**changeOwner**) только для владельца контракта:

```solidity
// Указываем версию компилятора Solidity, которую будем использовать
pragma solidity 0.8.0;

contract MyContract {
    // Переменная для хранения адреса владельца контракта
    address owner;

    // Конструктор вызывается при развертывании контракта. 
    // В нем устанавливается адрес владельца контракта.
    constructor() {
        owner = msg.sender; // msg.sender - это адрес, который инициировал развертывание контракта.
    }

    // Модификатор onlyOwner ограничивает выполнение функций только для владельца.
    modifier onlyOwner() {
        // require проверяет условие. Если оно ложно, выполнение прерывается.
        require(msg.sender == owner, "You are not the owner!"); 
        // Символ _; обозначает продолжение выполнения функции после выполнения модификатора.
        _;
    }

    // Функция для смены владельца контракта.
    // Использует модификатор onlyOwner для ограничения доступа.
    function changeOwner(address newOwner) public onlyOwner {
        owner = newOwner; // Меняем адрес владельца на новый.
    }
}
```

{{< admonition success "👶 Подробный разбор:" false >}}

1. `pragma solidity 0.8.0;` — указывает версию компилятора Solidity, с которой должен компилироваться данный контракт. Версия 0.8.0 включает важные обновления, в частности встроенную защиту от переполнений и недополнений целых чисел.
2. `contract MyContract {}` — объявление контракта с именем **MyContract**. Внутри фигурных скобок содержатся все данные и функции контракта.
3. `address owner;` — объявляется переменная **owner** типа **address** для хранения адреса владельца контракта. В Ethereum все счета и контракты представлены как адреса.
4. `constructor() { owner = msg.sender; }` — функция-конструктор, которая вызывается только один раз при создании контракта. Внутри конструктора переменной **owner** присваивается значение **msg.sender**, то есть адрес того, кто развернул контракт.
5. `modifier onlyOwner() { require(msg.sender == owner, "You are not the owner!"); _; }` — модификатор **onlyOwner** проверяет, что вызывающий функцию является владельцем контракта. Если это не так, выполнение функции прекращается с сообщением **"You are not the owner!"**. Символ **_;** означает, что после проверки выполнения модификатора продолжается выполнение основной функции.
6. `function changeOwner(address newOwner) public onlyOwner { owner = newOwner; }` — функция **changeOwner** позволяет сменить владельца контракта. Она принимает один аргумент — новый адрес владельца (**newOwner**). Модификатор **onlyOwner** ограничивает доступ к этой функции только владельцу текущего контракта.

{{< /admonition >}}

{{< admonition danger "👨‍🎓 Дополнительный пример:" false >}}

Контракт с несколькими уровнями доступа

Теперь давайте расширим тему, добавив пример с несколькими уровнями доступа, где есть владелец и администраторы.

```solidity
pragma solidity 0.8.0;

contract AccessControl {
    
    address public owner; // Владелец контракта
    mapping(address => bool) public admins; // Словарь для хранения статусов администраторов

    constructor() {
        owner = msg.sender; // Устанавливаем владельца контракта
    }

    // Модификатор, разрешающий выполнение функции только владельцу
    modifier onlyOwner() {
        require(msg.sender == owner, "You are not the owner!"); 
        _;
    }

    // Модификатор, разрешающий выполнение функции только администратору
    modifier onlyAdmin() {
        require(admins[msg.sender], "You are not an admin!"); 
        _;
    }

    // Функция для назначения нового администратора, доступна только владельцу
    function addAdmin(address admin) public onlyOwner {
        admins[admin] = true; // Добавляем администратора
    }

    // Функция для удаления администратора, доступна только владельцу
    function removeAdmin(address admin) public onlyOwner {
        admins[admin] = false; // Удаляем администратора
    }

    // Пример функции, которая может выполняться только администратором
    function adminTask() public onlyAdmin {
        // Выполнение важной задачи, доступной только администраторам
    }
}
```

**Объяснение кода:**

1. Администраторы: в этом примере мы вводим администраторов. Они хранятся в виде `mapping`, где каждому адресу сопоставляется логическое значение (`true` для администратора и `false` для остальных).

2. Модификатор `onlyAdmin()`: этот модификатор позволяет только администраторам вызывать функции, помеченные им.
    `addAdmin` и `removeAdmin`: эти функции позволяют владельцу назначать и удалять администраторов.

3. `adminTask()`: это пример функции, доступной только администраторам.

{{< /admonition >}}

**Преимущества использования модификаторов:**

- Удобство: модификаторы позволяют избегать повторения одного и того же кода в разных функциях. Например, проверку прав владельца можно вынести в модификатор и использовать его в нескольких функциях.
- Гибкость: модификаторы можно комбинировать и расширять, чтобы создавать сложные условия для выполнения функций.

**Подробнее о модификаторах доступа в документации: [Solidity Modifiers](https://docs.soliditylang.org/en/v0.8.0/contracts.html#function-modifiers)**.

### События и их использование

События в Solidity играют важную роль, так как они позволяют смарт-контрактам взаимодействовать с внешними приложениями, такими как пользовательские интерфейсы, через логирование событий в блокчейне. Это позволяет отслеживать действия, которые происходят внутри контракта, без необходимости постоянно опрашивать контракт.

> События в Solidity — это механизм, с помощью которого смарт-контракты могут записывать данные в лог блокчейна. Эти записи могут быть легко отслежены внешними приложениями, такими как пользовательские интерфейсы, или использованы для мониторинга активности смарт-контрактов без необходимости опроса состояния контракта.
>
> Основные преимущества использования событий:
>
> - **Экономия ресурсов**: запись события потребляет меньше газа, чем хранение данных в блокчейне.
> - **Удобство логирования**: события позволяют журналировать важные изменения или действия в контракте, такие как регистрирование нового пользователя, перевод средств, изменение состояния контракта и т.д.
> - **Простота взаимодействия**: внешние системы могут легко реагировать на события, подписываясь на них с использованием логов блокчейна.

Рассмотрим пример контракта, который использует событие для логирования регистрации новых пользователей:

```solidity
// Указываем версию компилятора Solidity
pragma solidity 0.8.0;

contract EventExample {

    // Определение события NewUserRegistered, которое будет логировать адрес пользователя и метку времени.
    event NewUserRegistered(address user, uint256 timestamp);

    // Функция для регистрации нового пользователя
    function registerUser() public {
        // Вызов события с передачей адреса пользователя (msg.sender) и текущей метки времени (block.timestamp)
        emit NewUserRegistered(msg.sender, block.timestamp); 
    }
}
```

Здесь событие **NewUserRegistered** записывает адрес пользователя и метку времени при вызове функции **registerUser**.

{{< admonition success "👶 Подробный разбор:" false >}}

1. `event UserRegistered(address user, string name, uint256 deposit, uint256 timestamp);` — событие **UserRegistered** логирует четыре параметра:

    - **address user** — адрес пользователя, который вызвал функцию.
    - **string name** — имя пользователя, переданное в функцию.
    - **uint256 deposit** — сумма депозита, которую указал пользователь.
    - **uint256 timestamp** — время регистрации.

2. `function registerUser(string memory name, uint256 deposit) public { require(deposit > 0, "Deposit must be greater than zero"); }` — функция регистрации нового пользователя. Она принимает два аргумента:

    - **name** — имя пользователя, передаваемое как строка.
    - **deposit** — сумма депозита в виде положительного числа.

    Функция использует оператор **require**, чтобы убедиться, что сумма депозита больше нуля. Если это условие не выполнено, выполнение прерывается с сообщением **"Deposit must be greater than zero"**.

3. `emit UserRegistered(msg.sender, name, deposit, block.timestamp);` — здесь событие **UserRegistered** вызывается и логируется с информацией о пользователе, его имени, сумме депозита и времени регистрации.

{{< /admonition >}}

{{< admonition danger "👨‍🎓 Дополнительный пример:" false >}}

Рассмотрим более сложный пример с несколькими событиями и параметрами. В этом контракте добавляется возможность регистрировать пользователя с именем и фиксировать сумму депозита:

```solidity
pragma solidity 0.8.0;

contract EventWithDetails {

    // Объявляем событие для логирования регистрации пользователя с адресом, именем и суммой депозита
    event UserRegistered(address user, string name, uint256 deposit, uint256 timestamp);

    // Функция для регистрации нового пользователя с именем и депозитом
    function registerUser(string memory name, uint256 deposit) public {
        require(deposit > 0, "Deposit must be greater than zero"); // Проверка, что депозит положителен

        // Логируем событие регистрации пользователя с именем и суммой депозита
        emit UserRegistered(msg.sender, name, deposit, block.timestamp);
    }
}
```

1. `event UserRegistered(address user, string name, uint256 deposit, uint256 timestamp);` — событие **UserRegistered** логирует четыре параметра:

    - **address user** — адрес пользователя, который вызвал функцию.
    - **string name** — имя пользователя, переданное в функцию.
    - **uint256 deposit** — сумма депозита, которую указал пользователь.
    - **uint256 timestamp** — время регистрации.

2. `function registerUser(string memory name, uint256 deposit) public { require(deposit > 0, "Deposit must be greater than zero"); }` — функция регистрации нового пользователя. Она принимает два аргумента:

    - **name** — имя пользователя, передаваемое как строка.
    - **deposit** — сумма депозита в виде положительного числа.

    Функция использует оператор **require**, чтобы убедиться, что сумма депозита больше нуля. Если это условие не выполнено, выполнение прерывается с сообщением **"Deposit must be greater than zero"**.

3. `emit UserRegistered(msg.sender, name, deposit, block.timestamp);` — здесь событие **UserRegistered** вызывается и логируется с информацией о пользователе, его имени, сумме депозита и времени регистрации.

##### Как просматривать события в блокчейне?

После вызова события данные сохраняются в логах блокчейна и могут быть прочитаны с помощью специальных средств (например, веб-интерфейсов или библиотек, таких как Web3.js). Пример кода на JavaScript для получения события с помощью Web3.js:

```javascript
const contract = new web3.eth.Contract(abi, contractAddress);

contract.getPastEvents('UserRegistered', {
    fromBlock: 0,
    toBlock: 'latest'
}, (error, events) => {
    if (!error) {
        console.log(events); // Список всех событий UserRegistered
    } else {
        console.error(error);
    }
});
```

{{< /admonition >}}

**Преимущества использования событий:**

- **Мониторинг контрактов**: события позволяют отслеживать изменения в контракте без необходимости постоянно проверять его состояние, что снижает затраты на газ.
- **Логирование важных данных**: события записывают важные данные, которые могут быть полезны для анализа или аудита контракта.
- **Уведомления для внешних систем**: внешние приложения могут подписываться на события контракта и реагировать на них в реальном времени.

**Официальная документация по событиям: [Solidity Events](https://docs.soliditylang.org/en/v0.8.0/contracts.html#events)**.

### Работа с массивами и структурами

Массивы и структуры позволяют хранить и организовывать данные в смарт-контрактах. Массивы могут быть статическими или динамическими, а структуры используются для создания более сложных объектов данных.

> В Solidity структуры и массивы позволяют эффективно организовывать и хранить сложные данные. **Структуры** (structs) используются для группировки различных типов данных в один логический объект, а **массивы** позволяют хранить несколько экземпляров таких объектов. В этом примере мы создаем контракт, который управляет данными пользователей, используя структуру и массив для хранения списка пользователей.
>
> Основные понятия:
>
> - **Структуры** в Solidity позволяют объединять несколько типов данных в единый объект. Это удобно для представления сложных данных, таких как профили пользователей, транзакции или контракты.
> - **Массивы** могут быть как статическими, так и динамическими. Динамические массивы, как в данном примере, позволяют добавлять элементы во время выполнения контракта.

Рассмотрим контракт, который хранит данные пользователей, используя структуру для хранения имени и баланса, и массив для хранения всех пользователей:

```solidity
// Указываем версию компилятора Solidity
pragma solidity 0.8.0;

contract DataStorage {

    // Определяем структуру User для хранения имени пользователя и его баланса
    struct User {
        string name;       // Имя пользователя (строка)
        uint256 balance;   // Баланс пользователя (целое число)
    }

    // Динамический массив пользователей типа User
    User[] public users;

    // Функция для добавления нового пользователя в массив users
    function addUser(string memory name, uint256 balance) public {
        // Добавляем новый экземпляр структуры User в массив users
        users.push(User(name, balance));
    }

    // Функция для получения данных пользователя по индексу
    function getUser(uint index) public view returns (string memory, uint256) {
        // Проверяем, что индекс находится в пределах длины массива
        require(index < users.length, "User does not exist");

        // Получаем ссылку на пользователя по индексу
        User storage user = users[index];

        // Возвращаем имя и баланс пользователя
        return (user.name, user.balance);
    }
}
```

В данном примере структура **User** хранит имя и баланс пользователя, а массив **users** используется для хранения всех пользователей.

{{< admonition success "👶 Подробный разбор:" false >}}

1. `pragma solidity 0.8.0;` — указывает на версию компилятора Solidity, используемую для компиляции этого контракта. Версия 0.8.0 включает важные обновления, такие как защита от переполнения чисел.
2. `contract DataStorage {}` — объявление контракта с именем **DataStorage**, который будет содержать структуру данных пользователей и функции для работы с ними.
3. `struct User { string name; uint256 balance; }` — объявление структуры **User**. Она используется для хранения данных о пользователе и включает два поля:
    - **name** — строка, представляющая имя пользователя.
    - **balance** — целое число (типа **uint256**), представляющее баланс пользователя.
4. `User[] public users;` — объявляется динамический массив **users**, который хранит элементы типа **User**. Этот массив будет использоваться для хранения всех пользователей, добавленных в контракт.
5. `function addUser(string memory name, uint256 balance) public { users.push(User(name, balance)); }` — функция **addUser** добавляет нового пользователя в массив:
    - **string memory name** — имя пользователя, переданное в функцию.
    - **uint256 balance** — баланс пользователя.
    - **users.push(User(name, balance))** — добавление нового пользователя в массив **users** с использованием функции **push**, которая добавляет элемент в конец массива.
6. `function getUser(uint index) public view returns (string memory, uint256)` — функция **getUser** возвращает данные пользователя по индексу:
    - **uint index** — индекс пользователя в массиве.
    - Функция помечена как **view**, что означает, что она только читает данные из блокчейна и не изменяет его состояние.
    - **require(index < users.length, "User does not exist");** — проверяет, что переданный индекс находится в пределах массива. Если индекс выходит за пределы, выполнение функции прекращается с сообщением об ошибке.
    - **User storage user = users[index];** — получает данные пользователя по индексу и сохраняет их в переменную **user**.
    - Возвращает имя и баланс пользователя.

{{< /admonition >}}

{{< admonition danger "👨‍🎓 Дополнительный пример:" false >}}

Добавим к контракту возможность изменять баланс пользователя по его индексу:

```solidity
pragma solidity 0.8.0;

contract DataStorageWithUpdate {

    struct User {
        string name;       // Имя пользователя
        uint256 balance;   // Баланс пользователя
    }

    User[] public users;

    // Функция для добавления нового пользователя
    function addUser(string memory name, uint256 balance) public {
        users.push(User(name, balance));
    }

    // Функция для получения данных пользователя по индексу
    function getUser(uint index) public view returns (string memory, uint256) {
        require(index < users.length, "User does not exist");
        User storage user = users[index];
        return (user.name, user.balance);
    }

    // Функция для обновления баланса пользователя
    function updateUserBalance(uint index, uint256 newBalance) public {
        require(index < users.length, "User does not exist"); // Проверяем, что пользователь существует
        User storage user = users[index]; // Получаем пользователя по индексу
        user.balance = newBalance;        // Обновляем баланс
    }
}
```

`updateUserBalance(uint index, uint256 newBalance)` — функция для обновления баланса пользователя:

- **require(index < users.length, "User does not exist");** — проверяет, что пользователь существует по переданному индексу.
- **User storage user = users[index];** — получает пользователя по индексу для изменения его данных.
- **user.balance = newBalance;** — обновляет баланс пользователя.

{{< /admonition >}}

**Важные аспекты работы с массивами и структурами:**

1. **Типы данных**: в Solidity существуют два типа памяти для данных — **storage** и **memory**.
    - **storage** указывает на хранение данных в блокчейне, что делает его дорогим в плане газа, но данные сохраняются навсегда.
    - **memory** используется для временных данных, которые исчезают после выполнения функции.
2. **Модификаторы функций**:
    - **view** — модификатор, указывающий, что функция не изменяет состояние блокчейна и может только считывать данные.
    - **public** — функция может быть вызвана как внутри контракта, так и извне.

**Преимущества использования структур и массивов:**

- **Организация данных**: структуры позволяют удобно организовать связанные данные, такие как имя и баланс пользователя.
- **Масштабируемость**: динамические массивы позволяют хранить неограниченное количество данных, добавляя элементы по мере необходимости.
- **Гибкость**: массивы и структуры позволяют легко управлять данными в смарт-контрактах и создавать более сложные системы.

**Документация по массивам и структурам: [Arrays and Structs in Solidity](https://docs.soliditylang.org/en/v0.8.0/types.html)**.

### Оптимизация контрактов и работа с gas

Каждая операция в смарт-контракте требует вычислительных ресурсов, измеряемых в **gas**. Важно писать код, который минимизирует использование **gas**, особенно в случае часто вызываемых функций.

> Каждая операция, выполняемая в блокчейне, требует вычислительных ресурсов, измеряемых в **gas**. Чем больше операций выполняется в контракте, тем больше газа он потребляет. Оптимизация смарт-контрактов направлена на снижение затрат на gas, что особенно важно при работе с большими объемами данных или частом выполнении функций.
>
> Основные понятия:
>
> - **Gas** — это плата за выполнение операций в блокчейне. Чем больше вычислений требует функция, тем больше газа нужно заплатить.
> - **Оптимизация** — процесс уменьшения количества операций для снижения потребления газа.

Несколько советов по оптимизации:

1. **Используйте память разумно**. переменные, объявленные как `storage`, дороже по gas, чем переменные в `memory`.
2. **Минимизируйте циклы**. циклы, особенно динамические, могут быть дорогостоящими в плане gas.
3. **События вместо хранения**. если данные не требуют постоянного хранения, используйте события для логирования, а не сохраняйте их в блокчейне.

В данном примере мы рассмотрим контракт, который добавляет числа в массив и возвращает их сумму. Важной частью является оптимизация цикла для минимизации обращения к длине массива. 

> Ниже смарт-контракт, который содержит массив чисел и позволяет как добавлять числа, так и рассчитывать их сумму. Для снижения затрат на gas при работе с массивом применяется оптимизация — вместо многократного обращения к длине массива, она сохраняется в переменной.

```solidity
// Указываем версию компилятора Solidity
pragma solidity 0.8.0;

contract GasOptimized {

    // Динамический массив для хранения чисел
    uint256[] public numbers;

    // Функция для добавления нового числа в массив numbers
    function addNumber(uint256 num) public {
        numbers.push(num); // Добавляем новое число в массив
    }

    // Функция для вычисления суммы всех чисел в массиве numbers
    function getNumbersSum() public view returns (uint256 sum) {
        uint256 length = numbers.length; // Оптимизация: сохраняем длину массива в переменную
        for (uint256 i = 0; i < length; i++) { // Проходим по всем элементам массива
            sum += numbers[i]; // Добавляем каждое число к переменной sum
        }
    }
}
```

В этом примере мы сохраняем длину массива в отдельную переменную перед циклом, что снижает количество обращений к переменной массива в каждом шаге цикла.

{{< admonition success "👶 Подробный разбор:" false >}}

1. `pragma solidity 0.8.0;` — указывает на версию компилятора Solidity, используемую для компиляции этого контракта.
2. `contract GasOptimized {}` — объявление контракта с именем **GasOptimized**, который будет содержать массив чисел и функции для работы с ними.
3. `uint256[] public numbers;` — объявляется динамический массив **numbers**, который будет хранить числа. Массив является публичным, что означает, что его можно просматривать вне контракта.
4. `function addNumber(uint256 num) public { numbers.push(num); }` — функция **addNumber** добавляет новое число в массив **numbers**:
    - **uint256 num** — число, передаваемое в функцию для добавления в массив.
    - **numbers.push(num);** — добавляет новое число в конец массива.
5. `function getNumbersSum() public view returns (uint256 sum)` — функция **getNumbersSum** возвращает сумму всех чисел в массиве:
    - Функция помечена как **view**, что означает, что она не изменяет состояние блокчейна.
    - **uint256 length = numbers.length;** — сохраняем длину массива **numbers** в переменную **length** для оптимизации цикла.
    - Внутри цикла, вместо многократного обращения к **numbers.length**, мы используем переменную **length**. Это снижает количество операций и, следовательно, потребление газа.
    - **sum += numbers[i];** — добавляем значение каждого элемента массива к переменной **sum**.

{{< /admonition >}}

{{< admonition danger "👨‍🎓 Дополнительный пример:" false >}}

Пример с дополнительной оптимизацией: Минимизация затрат на gas при расчетах

Добавим дополнительную функцию, которая будет использовать ещё одну оптимизацию — досрочный выход из цикла, если обнаружено определенное условие.

```solidity
pragma solidity 0.8.0;

contract GasOptimizedWithBreak {

    uint256[] public numbers;

    // Функция для добавления числа в массив numbers
    function addNumber(uint256 num) public {
        numbers.push(num);
    }

    // Функция для нахождения суммы всех чисел в массиве, с условием остановки, если сумма превышает лимит
    function getNumbersSumWithLimit(uint256 limit) public view returns (uint256 sum) {
        uint256 length = numbers.length; // Оптимизация: сохраняем длину массива
        for (uint256 i = 0; i < length; i++) {
            sum += numbers[i]; // Добавляем каждое число к сумме
            if (sum > limit) {  // Если сумма превышает указанный лимит
                break;          // Останавливаем цикл досрочно
            }
        }
    }
}
```

`getNumbersSumWithLimit(uint256 limit)` — функция для вычисления суммы всех чисел в массиве, но с условием:

- **uint256 limit** — значение лимита, при превышении которого цикл завершится досрочно.
- **if (sum > limit) { break; }** — если сумма всех чисел превышает указанный лимит, цикл останавливается, что экономит gas за счет уменьшения количества итераций.

{{< /admonition >}}

**Важные аспекты оптимизации:**

1. **Сохранение состояния переменных**: при многократном использовании свойств или переменных, таких как длина массива, рекомендуется сохранять их значения в отдельные переменные, чтобы избежать лишних вызовов. Это уменьшает количество операций и снижает затраты на gas.
2. **Досрочный выход из циклов**: использование условий для досрочного завершения цикла может значительно сократить количество выполняемых операций и снизить потребление газа.
3. **Оптимизация циклов**: циклы могут быть дорогими в плане газа, особенно при большом количестве итераций. Если цикл не может быть избегнут, его нужно оптимизировать, как показано выше.

**Преимущества оптимизации смарт-контрактов:**

- **Экономия газа**: оптимизация кода снижает количество операций, что уменьшает затраты на выполнение функций.
- **Улучшение производительности**: более оптимизированный код выполняется быстрее и требует меньше вычислительных ресурсов, что может быть критически важно для крупных контрактов с большим количеством данных.
- **Повышение устойчивости**: уменьшение потребления газа делает контракт более устойчивым к ошибкам, связанным с превышением лимита газа.

**Дополнительная информация по оптимизации: [Solidity Gas Optimization](https://hacken.io/discover/solidity-gas-optimization/)**, [Awesome Solidity Gas-Optimization](https://github.com/0xisk/awesome-solidity-gas-optimization).

### Безопасность смарт-контрактов

Безопасность — один из ключевых аспектов разработки смарт-контрактов. Одной из наиболее известных уязвимостей является **повторная атака (Reentrancy)**. Эта уязвимость позволяет злоумышленнику многократно вызывать одну и ту же функцию до того, как завершится её исходное выполнение. Повторные атаки могут привести к краже средств из контракта.

Для предотвращения подобных атак в Solidity часто используют **модификаторы**, которые блокируют повторное выполнение функций, пока не завершится текущий вызов.

> Основные понятия:
>
> - **Reentrancy** — это тип уязвимости, при которой злоумышленник может многократно вызывать одну и ту же функцию до завершения её первого вызова, манипулируя состоянием контракта в обход правил.
> - **Модификатор noReentrancy** — предотвращает повторные вызовы одной и той же функции до завершения предыдущего выполнения, что защищает контракт от атаки.

Безопасность должна быть в приоритете при разработке смарт-контрактов, так как ошибки могут привести к потере средств. Вот несколько основных аспектов, которые необходимо учитывать:

1. **Проверка входных данных**: dсегда проверяйте входные данные, особенно адреса и суммы, чтобы избежать непредвиденных ошибок.
2. **Переполнение и недополнение чисел**: c версии Solidity 0.8.0, встроена проверка переполнения, но важно помнить о ней при работе с более старыми версиями.
3. **Защита от повторных атак (Reentrancy)**: и спользуйте паттерн **"проверка-эффект-вызов"** при отправке средств или изменении состояний контракта.

Пример защиты от повторной атаки, где мы создаём смарт-контракт, который защищён от повторных атак с использованием модификатора **noReentrancy**.

```solidity
pragma solidity 0.8.0;

// Указываем версию компилятора Solidity
contract SecureContract {

    // Словарь для хранения балансов пользователей
    mapping(address => uint256) balances;

    // Переменная для блокировки повторного вызова функции
    bool internal locked;

    // Модификатор для предотвращения повторных атак (Reentrancy)
    modifier noReentrancy() {
        require(!locked, "Reentrancy detected!"); // Проверяем, что функция не заблокирована
        locked = true; // Блокируем выполнение функции до её завершения
        _; // Выполнение основной функции
        locked = false; // Разблокируем функцию после завершения
    }

    // Функция для вывода средств с контракта
    function withdraw(uint256 amount) public noReentrancy {
        // Проверяем, что баланс пользователя достаточен для вывода средств
        require(balances[msg.sender] >= amount, "Insufficient balance");

        // Уменьшаем баланс пользователя на сумму вывода
        balances[msg.sender] -= amount;

        // Переводим средства на адрес пользователя
        payable(msg.sender).transfer(amount);
    }
}
```

{{< admonition success "👶 Подробный разбор:" false >}}

1. `pragma solidity 0.8.0;` — указывает версию компилятора Solidity. Версия 0.8.0 включает встроенную защиту от переполнений чисел и другие обновления безопасности.
2. `mapping(address => uint256) balances;` — создаём **mapping** (словарь), который хранит балансы пользователей. Каждому адресу (типа **address**) сопоставляется баланс (типа **uint256**).
3. `bool internal locked;` — переменная **locked** используется для блокировки выполнения функции во время её текущего вызова. Она объявлена как **internal**, что означает, что к ней могут обращаться только внутри этого контракта или его наследников.
4. `modifier noReentrancy() { ... }` — модификатор **noReentrancy** предотвращает повторное выполнение функции до завершения текущего вызова:
    - **require(!locked, "Reentrancy detected!");** — проверяет, что функция не заблокирована. Если она уже выполняется, выбрасывается ошибка с сообщением **"Reentrancy detected!"**.
    - **locked = true;** — блокирует выполнение функции.
    - **_;** — символ, который означает выполнение основной функции, к которой применяется модификатор.
    - **locked = false;** — после завершения функции блокировка снимается, и функция снова может быть вызвана.
5. `function withdraw(uint256 amount) public noReentrancy { ... }` — функция для вывода средств:
    - **noReentrancy** — модификатор, предотвращающий повторные вызовы функции **withdraw**.
    - **require(balances[msg.sender] >= amount, "Insufficient balance");** — проверяет, что у пользователя достаточно средств на балансе для вывода указанной суммы.
    - **balances[msg.sender] -= amount;** — уменьшает баланс пользователя на сумму вывода.
    - **payable(msg.sender).transfer(amount);** — переводит средства на адрес вызывающего функцию пользователя.

{{< /admonition >}}

{{< admonition danger "👨‍🎓 Дополнительный пример:" false >}}

Пример с дополнительными функциями: пополнение и проверка баланса. Добавим возможность пополнять баланс и проверять текущий баланс пользователя.

```solidity
pragma solidity 0.8.0;

contract SecureContractWithDeposit {

    mapping(address => uint256) public balances;
    bool internal locked;

    modifier noReentrancy() {
        require(!locked, "Reentrancy detected!");
        locked = true;
        _;
        locked = false;
    }

    // Функция для пополнения баланса
    function deposit() public payable {
        require(msg.value > 0, "Deposit amount must be greater than zero");
        balances[msg.sender] += msg.value; // Добавляем полученные средства на баланс пользователя
    }

    // Функция для вывода средств с контракта
    function withdraw(uint256 amount) public noReentrancy {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }

    // Функция для проверки баланса пользователя
    function checkBalance() public view returns (uint256) {
        return balances[msg.sender];
    }
}
```

1. `deposit()` — функция для пополнения баланса:
    - **msg.value** — сумма средств, переданная в функцию.
    - **balances[msg.sender] += msg.value;** — увеличивает баланс пользователя на переданную сумму.
2. `checkBalance()` — функция для проверки текущего баланса вызывающего:
    - **returns (uint256)** — возвращает баланс пользователя (типа **uint256**).

{{< /admonition >}}

**Важные аспекты защиты от повторных атак:**

1. **Принцип "проверка-эффект-вызов"** ([Checks-Effects-Interactions Pattern](https://medium.com/@dehvcurtis/robust-smart-contracts-checks-effects-interactions-pattern-for-secure-dapps-6498bb4af893)): это важный принцип, который рекомендуется использовать для защиты смарт-контрактов от повторных атак. Он заключается в том, что сначала проверяются все условия, затем изменяется состояние контракта (например, обновляется баланс), и только после этого выполняются внешние вызовы, такие как отправка средств.
2. **Использование модификаторов**: модификаторы, такие как **noReentrancy**, помогают упростить проверку условий безопасности перед выполнением функций. Это делает код более читабельным и защищённым от ошибок.

**Преимущества защиты от повторных атак:**

- **Защита средств**: использование модификаторов, таких как **noReentrancy**, помогает предотвратить кражу средств из контракта путём повторных вызовов функций.
- **Простота внедрения**: модификатор легко интегрируется в контракт, обеспечивая дополнительный уровень защиты без значительных изменений в коде.
- **Универсальность**: модификатор **noReentrancy** можно использовать во многих функциях контракта, где возможен риск повторных атак.

**Дополнительная информация о безопасности: [Solidity Security Considerations](https://docs.soliditylang.org/en/latest/security-considerations.html)**.

### Заключение и дорожная карта

Мы рассмотрели важные аспекты разработки смарт-контрактов на языке Solidity, включая базовые и продвинутые методы защиты контрактов от уязвимостей, таких как повторные атаки. В ходе изучения были предложены примеры оптимизации работы контрактов, эффективное использование модификаторов и построение безопасных логик для управления средствами пользователей. Закрепление знаний с помощью практических заданий разного уровня сложности позволило понять, как создавать более защищённые и оптимизированные смарт-контракты.

**Основные выводы:**

1. **Безопасность смарт-контрактов**: защита от повторных атак (Reentrancy) является важнейшим элементом при работе с функциями, связанными с передачей средств, и может быть реализована с помощью модификатора **noReentrancy**.
   
2. **Модификаторы и роли**: модификаторы позволяют упрощать код и эффективно управлять доступом к функциям контракта. Использование роли "владельца" (через модификатор **onlyOwner**) помогает ограничивать доступ к критическим функциям.
   
3. **Оптимизация газа**: снижение затрат на выполнение операций в блокчейне (gas) является важным шагом при разработке контрактов. Оптимизация цикла или хранения данных уменьшает количество операций и делает контракт более экономичным.

4. **Практические задачи**: выполнение заданий разного уровня сложности позволило лучше понять, как защитить контракт от уязвимостей, как управлять данными пользователей и как минимизировать затраты на gas.

Разработка смарт-контрактов требует глубокого понимания как технических аспектов языка Solidity, так и вопросов безопасности. Важно не только создавать функциональные контракты, но и обеспечивать их устойчивость к атакам. Мы изучили, как защитить смарт-контракты от повторных атак, эффективно использовать модификаторы для упрощения кода и снижения затрат на gas. Применение этих знаний на практике поможет вам создавать более надёжные и безопасные смарт-контракты.

Смарт-контракты — это фундамент блокчейн-экосистемы, и ваша задача, как разработчика, заключается в том, чтобы создавать решения, которые будут безопасны, эффективны и функциональны. Мы надеемся, что данный материал помог вам расширить свои знания и навыки, а предложенные задачи позволят лучше усвоить ключевые аспекты разработки на Solidity.

Разработка смарт-контрактов на языке Solidity требует систематического подхода для углубления знаний и навыков. Эта дорожная карта поможет вам шаг за шагом погружаться в мир блокчейна, осваивать продвинутые методы программирования, улучшать безопасность и оптимизировать свои контракты.


1. **Углубленное изучение языка Solidity**

> **Цель**: Полностью освоить язык Solidity и его возможности.
>
> **Шаги**:
>
> - Изучите официальную документацию Solidity: [Solidity Documentation](https://docs.soliditylang.org).
> - Разберитесь с продвинутыми темами:
>     - Управление памятью: **storage**, **memory**, **calldata**.
>     - Обработка ошибок с помощью **require**, **revert**, **assert**.
>     - Использование **events** для логирования и их взаимодействие с внешними системами.
>     - Наследование и библиотеки.
>
> **Практическое задание**:
>
> - Создайте смарт-контракт с продвинутыми типами данных и оптимизацией работы с памятью.
>
> **Результат**:
>
> - Полное понимание возможностей языка Solidity и реализация продвинутых функций.

2. **Изучение безопасности смарт-контрактов**

> **Цель**: Научиться предотвращать основные уязвимости смарт-контрактов.
>
> **Шаги**:
>
> - Изучите ключевые уязвимости:
>     - **Reentrancy** (повторная атака).
>     - **Integer Overflow/Underflow** (переполнение целых чисел).
>     - **Front-Running** (предварительное выполнение транзакций).
>     - **Denial of Service** (отказ в обслуживании).
> - Прочитайте руководство по безопасности от ConsenSys: [Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/).
>
> **Практическое задание**:
>
> - Проведите аудит контракта и устраните возможные уязвимости.
>
> **Результат**:
>
> - Навыки проектирования безопасных смарт-контрактов и защита от распространённых атак.

3. **Оптимизация газовых затрат**

> **Цель**: Научиться оптимизировать контракты для снижения затрат на gas.
>
> **Шаги**:
>
> - Изучите, как рассчитываются gas-затраты в блокчейне Ethereum.
> - Оптимизируйте использование памяти и минимизируйте количество операций.
> - Изучите методы сокращения gas при работе с данными.
>
> **Практическое задание**:
>
> - Разверните контракт на тестовой сети и измерьте затраты на gas до и после оптимизации.
>
> **Результат**:
>
> - Способность проектировать контракты, минимизирующие затраты на выполнение операций.

4. **Изучение паттернов проектирования смарт-контрактов**

> **Цель**: Научиться применять архитектурные паттерны для создания масштабируемых смарт-контрактов.
>
> **Шаги**:
>
> - Изучите паттерны: **Proxy**, **Factory**, **Ownable**, **Pausable**.
> - Ознакомьтесь с OpenZeppelin: [OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts).
>
> **Практическое задание**:
>
> - Реализуйте контракт с возможностью обновления через **Proxy** и контракт-фабрику.
>
> **Результат**:
>
> - Способность проектировать масштабируемые и модульные смарт-контракты.

5. **Работа с оракулами и внешними данными (Chainlink)**

> **Цель**: Научиться подключать смарт-контракты к внешним данным через оракулы.
>
> **Шаги**:
>
> - Изучите работу оракулов и их роль в блокчейне.
> - Ознакомьтесь с Chainlink: [Chainlink Documentation](https://docs.chain.link/).
> - Реализуйте случайную генерацию чисел (RNG) через Chainlink.
>
> **Практическое задание**:
>
> - Напишите контракт, получающий данные из внешнего API через **Chainlink Oracles**.
>
> **Результат**:
>
> - Навыки работы с оракулами и их интеграции с внешними источниками данных.

6. **Разработка децентрализованных приложений (DApps)**

> **Цель**: Научиться интегрировать смарт-контракты с фронтенд-приложениями.
>
> **Шаги:
>
> - Изучите React, Web3.js и Ethers.js для разработки интерфейсов DApp.
> - Изучите **Truffle**, **Hardhat** и **Ganache** для развертывания и тестирования смарт-контрактов.
>
> **Практическое задание**:
>
> - Реализуйте простое децентрализованное приложение (DApp), взаимодействующее со смарт-контрактом.
>
> **Результат**:
>
> - Умение разрабатывать и интегрировать смарт-контракты с пользовательскими интерфейсами.

7. **Тестирование и аудит смарт-контрактов**

> **Цель**: Освоить методы тестирования смарт-контрактов и проведения аудитов.
>
> **Шаги**:
>
> - Изучите инструменты для тестирования: **Truffle**, **Hardhat**, **Chai**, **Mocha**.
> - Используйте **MythX**, **Slither**, **Echidna** для автоматического аудита.
>
> **Практическое задание**:
>
> - Напишите юнит-тесты для своего контракта и проведите аудит кода с помощью автоматических инструментов.
>
> **Результат**:
>
> - Способность тестировать и проводить аудит смарт-контрактов для обеспечения их безопасности.

Данная дорожная карта охватывает ключевые аспекты разработки и оптимизации смарт-контрактов на Solidity. Пройдя все этапы, вы сможете глубже погрузиться в вопросы безопасности, масштабирования и интеграции с внешними системами. Практика и изучение реальных примеров помогут вам стать профессиональным разработчиком, создающим надежные и эффективные блокчейн-решения.

Смарт-контракты — это не просто программы, а основа для создания децентрализованных систем будущего. Следуя этой дорожной карте, вы сможете стать экспертом в области разработки на Solidity и внести свой вклад в развитие блокчейн-технологий.

---

### Задание 1: Базовый

Создайте смарт-контракт, который позволяет пользователю пополнять свой баланс и затем выводить средства. Реализуйте защиту от повторных атак (Reentrancy) при выводе средств.

**Условия:**

1. Контракт должен содержать две функции:
   - **deposit()** для пополнения баланса.
   - **withdraw(uint256 amount)** для вывода средств.
2. Используйте модификатор для защиты от повторных атак.

<!--

##### Решение:

```solidity
pragma solidity 0.8.0;

contract BasicSecureContract {
    mapping(address => uint256) public balances;
    bool internal locked;

    modifier noReentrancy() {
        require(!locked, "Reentrancy detected!");
        locked = true;
        _;
        locked = false;
    }

    // Функция для пополнения баланса
    function deposit() public payable {
        require(msg.value > 0, "Deposit must be greater than zero");
        balances[msg.sender] += msg.value;
    }

    // Функция для вывода средств
    function withdraw(uint256 amount) public noReentrancy {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
}
```

##### Объяснение:
- Использован модификатор **noReentrancy**, чтобы предотвратить повторную атаку при выводе средств.
- Функция **deposit()** позволяет пользователю пополнить баланс, а **withdraw()** — вывести средства с баланса, при этом защита от повторных атак гарантирует безопасность.

-->


### Задание 2: Средний

Расширьте предыдущий контракт, добавив функцию для перевода средств от одного пользователя другому. Реализуйте защиту от повторных атак при переводе, а также возможность проверки баланса.

**Условия:**

1. Добавьте функцию **transfer(address to, uint256 amount)** для перевода средств.
2. Добавьте функцию **checkBalance()** для проверки баланса вызывающего пользователя.
3. Используйте защиту от повторных атак при переводе средств.

<!--

##### Решение:

```solidity
pragma solidity 0.8.0;

contract SecureContractWithTransfer {
    mapping(address => uint256) public balances;
    bool internal locked;

    modifier noReentrancy() {
        require(!locked, "Reentrancy detected!");
        locked = true;
        _;
        locked = false;
    }

    // Функция для пополнения баланса
    function deposit() public payable {
        require(msg.value > 0, "Deposit must be greater than zero");
        balances[msg.sender] += msg.value;
    }

    // Функция для вывода средств
    function withdraw(uint256 amount) public noReentrancy {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }

    // Функция для перевода средств другому пользователю
    function transfer(address to, uint256 amount) public noReentrancy {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        require(to != address(0), "Invalid address");

        balances[msg.sender] -= amount;
        balances[to] += amount;
    }

    // Функция для проверки баланса
    function checkBalance() public view returns (uint256) {
        return balances[msg.sender];
    }
}
```

##### Объяснение:
- Добавлена функция **transfer()**, которая позволяет перевести средства от одного пользователя другому, с использованием защиты от повторных атак.
- Функция **checkBalance()** возвращает баланс вызывающего пользователя.
- Модификатор **noReentrancy** предотвращает атаки как на функцию **withdraw()**, так и на **transfer()**.

-->

### Задание 3: Продвинутый

Реализуйте контракт с возможностью управления ролями (владелец и пользователь). Только владелец может вызывать функции для вывода средств и перевода, пользователи могут только пополнять баланс. Реализуйте защиту от повторных атак при выводе средств владельцем и перевода средств другим пользователям.

**Условия:**

1. Введите разделение ролей: владелец и пользователь.
2. Владелец может управлять средствами (выводить и переводить).
3. Пользователь может только пополнять баланс.
4. Реализуйте защиту от повторных атак для владельца при выводе и переводе средств.

<!--

##### Решение:

```solidity
pragma solidity 0.8.0;

contract RoleBasedSecureContract {
    address public owner;
    mapping(address => uint256) public balances;
    bool internal locked;

    modifier noReentrancy() {
        require(!locked, "Reentrancy detected!");
        locked = true;
        _;
        locked = false;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "You are not the owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    // Функция для пополнения баланса пользователями
    function deposit() public payable {
        require(msg.value > 0, "Deposit must be greater than zero");
        balances[msg.sender] += msg.value;
    }

    // Функция для вывода средств владельцем
    function withdraw(uint256 amount) public onlyOwner noReentrancy {
        require(balances[owner] >= amount, "Insufficient balance");
        balances[owner] -= amount;
        payable(owner).transfer(amount);
    }

    // Функция для перевода средств владельцем
    function transfer(address to, uint256 amount) public onlyOwner noReentrancy {
        require(balances[owner] >= amount, "Insufficient balance");
        require(to != address(0), "Invalid address");

        balances[owner] -= amount;
        balances[to] += amount;
    }

    // Функция для проверки баланса пользователя
    function checkBalance() public view returns (uint256) {
        return balances[msg.sender];
    }
}
```

##### Объяснение:
- Добавлена логика ролей с модификатором **onlyOwner**, который разрешает выполнение определённых функций только владельцу.
- Владелец может выводить и переводить средства, используя функции **withdraw()** и **transfer()**.
- Пользователи могут только пополнять баланс через функцию **deposit()**.
- Защита от повторных атак осуществляется с помощью модификатора **noReentrancy** для всех функций управления средствами владельца.

-->

<div style="text-align: center;">***</div>