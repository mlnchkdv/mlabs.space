---
weight: 1
title:  Классификация, деревья решений и k-ближайших соседей
description: Classification, Decision Trees and k Nearest Neighbors
author: MLabs
authorLink: null
date: 2023-07-30T14:48:57.920Z
lastmod: null
slug: classification
categories:
  - IIS
math: true
lightgallery: true
toc:
  auto: false
draft: false
---

## Введение

Классическое, общее определение машинного обучения звучит так (T. Mitchell "Machine learning", 1997):

> говорят, что компьютерная программа _обучается_ при решении какой-то задачи из класса _T_, если ее производительность, согласно метрике _P_, улучшается при накоплении опыта _E_.

Далее в разных сценариях под _T, P_, и _E_ подразумеваются совершенно разные вещи. Среди самых популярных **задач _T_ в машинном обучении**: 

-   классификация – отнесение объекта к одной из категорий на основании его признаков
-   регрессия – прогнозирование количественного признака объекта на основании прочих его признаков
-   кластеризация – разбиение множества объектов на группы на основании признаков этих объектов так, чтобы внутри групп объекты были похожи между собой, а вне одной группы – менее похожи
-   детекция аномалий – поиск объектов, "сильно непохожих" на все остальные в выборке либо на какую-то группу объектов
-   и много других, более специфичных. Хороший обзор дан в главе "Machine Learning basics" книги ["Deep Learning"](http://www.deeplearningbook.org/) (Ian Goodfellow, Yoshua Bengio, Aaron Courville, 2016)

Под **опытом _E_** понимаются данные (без них никуда), и в зависимости от этого алгоритмы машинного обучения могут быть поделены на те, что обучаются _с учителем_ и _без учителя_ (supervised & unsupervised learning). В задачах обучения без учителя имеется _выборка_, состоящая из _объектов_, описываемых набором _признаков_. В задачах обучения с учителем вдобавок к этому для каждого объекта некоторой выборки, называемой _обучающей_, известен _целевой признак_ – по сути это то, что хотелось бы прогнозировать для прочих объектов, не из обучающей выборки.

  

#### Пример

Задачи классификации и регрессии – это задачи обучения с учителем. В качестве примера будем представлять задачу кредитного скоринга: на основе накопленных кредитной организацией данных о своих клиентах хочется прогнозировать невозврат кредита. Здесь для алгоритма опыт _E_ – это имеющаяся обучающая выборка: набор _объектов_ (людей), каждый из которых характеризуется набором _признаков_ (таких как возраст, зарплата, тип кредита, невозвраты в прошлом и т.д.), а также _целевым признаком_. Если этот целевой признак – просто факт невозврата кредита (1 или 0, т.е. банк знает о своих клиентах, кто вернул кредит, а кто – нет), то это задача (бинарной) классификации. Если известно, _на сколько_ по времени клиент затянул с возвратом кредита и хочется то же самое прогнозировать для новых клиентов, то это будет задачей регрессии.

Наконец, третья абстракция в определении машинного обучения – это **метрика оценки производительности алгоритма _P_.** Такие метрики различаются для разных задач и алгоритмов, и про них мы будим говорить по мере изучения алгоритмов. Пока скажем, что самая простая метрика качества алгоритма, решающего задачу классификации – это доля правильных ответов (_accuracy_, не называйте ее _точностью_, этот перевод зарезервирован под другую метрику, _precision_) – то есть попросту доля верных прогнозов алгоритма на тестовой выборке.

Далее будем говорить о двух задачах обучения с учителем: о классификации и регресcии.

  

## Дерево решений

Начнем обзор методов классификации и регрессии с одного из самых популярных – с дерева решений. Деревья решений используются в повседневной жизни в самых разных областях человеческой деятельности, порой и очень далеких от машинного обучения. Деревом решений можно назвать наглядную инструкцию, что делать в какой ситуации. Приведем пример из области консультирования научных сотрудников института. Высшая Школа Экономики выпускает инфо-схемы, облегчающие жизнь своим сотрудникам. Вот фрагмент инструкции по публикации научной статьи на портале института.

![](https://habrastorage.org/r/w1560/files/401/8cd/bea/4018cdbea7a64306be94ed784fce4a06.png " ")

В терминах машинного обучения можно сказать, что это элементарный классификатор, который определяет форму публикации на портале (книга, статья, глава книги, препринт, публикация в "НИУ ВШЭ и СМИ") по нескольким признакам: типу публикации (монография, брошюра, статья и т.д.), типу издания, где опубликована статья (научный журнал, сборник трудов и т.д.) и остальным.

Зачастую дерево решений служит обобщением опыта экспертов, средством передачи знаний будущим сотрудникам или моделью бизнес-процесса компании. Например, до внедрения масштабируемых алгоритмов машинного обучения в банковской сфере задача кредитного скоринга решалась экспертами. Решение о выдаче кредита заемщику принималось на основе некоторых интуитивно (или по опыту) выведенных правил, которые можно представить в виде дерева решений.

![](https://habrastorage.org/files/194/9b6/ae9/1949b6ae97ab4fc9b1a37fbf182eda8f.gif " ")

В этом случае можно сказать, что решается задача бинарной классификации (целевой класс имеет два значения: "Выдать кредит" и "Отказать") по признакам "Возраст", "Наличие дома", "Доход" и "Образование".

Дерево решений как алгоритм машинного обучения – по сути то же самое: объединение логических правил вида "Значение признака ![$a$](https://habrastorage.org/getpro/habr/formulas/8f4/5ac/495/8f45ac4953a8010207f0f92306982b3b.svg) меньше ![$x$](https://habrastorage.org/getpro/habr/formulas/4cc/fd4/32e/4ccfd432ea4f2a64f3a5c8c7378517af.svg) И Значение признака ![$b$](https://habrastorage.org/getpro/habr/formulas/39d/180/62d/39d18062d6d75592f56b1b38409a5e10.svg) меньше ![$y$](https://habrastorage.org/getpro/habr/formulas/8f8/c2f/a70/8f8c2fa70a7019d42baacce3ac56acd3.svg)… => Класс 1" в структуру данных "Дерево". Огромное преимущество деревьев решений в том, что они легко интерпретируемы, понятны человеку. Например, по схеме на рисунке выше можно объяснить заемщику, почему ему было отказано в кредите. Скажем, потому, что у него нет дома и доход меньше 5000. Как мы увидим дальше, многие другие, хоть и более точные, модели не обладают этим свойством и могут рассматриваться скорее как "черный ящик", в который загрузили данные и получили ответ. В связи с этой "понятностью" деревьев решений и их сходством с моделью принятия решений человеком (можно легко объяснять боссу свою модель), деревья решений получили огромную популярность, а один из представителей этой группы методов классификации, С4.5, рассматривается первым в списке 10 лучших алгоритмов интеллектуального анализа данных ("Top 10 algorithms in data mining", Knowledge and Information Systems, 2008. [PDF](https://raw.githubusercontent.com/csuldw/MachineLearning/master/doc/10Algorithms-08.pdf)).

  

### Как строится дерево решений

В примере с кредитным скорингом мы видели, что решение о выдаче кредита принималось на основе возраста, наличия недвижимости, дохода и других. Но какой признак выбрать первым? Для этого рассмотрим пример попроще, где все признаки бинарные.

Здесь можно вспомнить игру "20 вопросов", которая часто упоминается во введении в деревья решений. Наверняка каждый в нее играл. Один человек загадывает знаменитость, а второй пытается отгадать, задавая только вопросы, на которые можно ответить "Да" или "Нет" (опустим варианты "не знаю" и "не могу сказать"). Какой вопрос отгадывающий задаст первым делом? Конечно, такой, который сильнее всего уменьшит количество оставшихся вариантов. К примеру, вопрос "Это Анджелина Джоли?" в случае отрицательного ответа оставит более 7 миллиардов вариантов для дальнейшего перебора (конечно, поменьше, не каждый человек – знаменитость, но все равно немало), а вот вопрос "Это женщина?" отсечет уже около половины знаменитостей. То есть, признак "пол" намного лучше разделяет выборку людей, чем признак "это Анджелина Джоли", "национальность-испанец" или "любит футбол". Это интуитивно соответствует понятию прироста информации, основанного на энтропии.

  

#### Энтропия

Энтропия Шеннона определяется для системы с ![$N$](https://habrastorage.org/getpro/habr/formulas/9aa/e08/704/9aae087046a60218262bab4a00522adc.svg) возможными состояниями следующим образом:

$$
\Large S = -\sum_{i=1}^{N}p_i \log_2{p_i},
$$

где $p_i$ – вероятности нахождения системы в $i$-ом состоянии. Это очень важное понятие, используемое в физике, теории информации и других областях. Опуская предпосылки введения (комбинаторные и теоретико-информационные) этого понятия, отметим, что, интуитивно, энтропия соответствует степени хаоса в системе. Чем выше энтропия, тем менее упорядочена система и наоборот. Это поможет нам формализовать "эффективное разделение выборки", про которое мы говорили в контексте игры "20 вопросов".

  

#### Пример

Для иллюстрации того, как энтропия поможет определить хорошие признаки для построения дерева, приведем тот же игрушечный пример, что в статье ["Энтропия и деревья принятия решений"](https://habrahabr.ru/post/171759/). Будем предсказывать цвет шарика по его координате. Конечно, ничего общего с жизнью это не имеет, но позволяет показать, как энтропия используется для построения дерева решений.

![](https://habrastorage.org/r/w1560/files/c96/80a/a4b/c9680aa4babc40f4bbc8b3595e203979.png " ")

Здесь 9 синих шариков и 11 желтых. Если мы наудачу вытащили шарик, то он с вероятностью $p_1=\frac{9}{20}$ будет синим и с вероятностью $p_2=\frac{11}{20}$ – желтым. Значит, энтропия состояния $S_0 = -\frac{9}{20}\log_2{\frac{9}{20}}-\frac{11}{20}\log_2{\frac{11}{20}} \approx 1$. Само это значение пока ни о чем нам не говорит. Теперь посмотрим, как изменится энтропия, если разбить шарики на две группы – с координатой меньше либо равной 12 и больше 12.

![](https://habrastorage.org/r/w1560/files/186/444/a8b/186444a8bd0e451c8324ca8529f8d4f4.png " ")

В левой группе оказалось 13 шаров, из которых 8 синих и 5 желтых. Энтропия этой группы равна $S_1 = -\frac{5}{13}\log_2{\frac{5}{13}}-\frac{8}{13}\log_2{\frac{8}{13}} \approx 0.96$. В правой группе оказалось 7 шаров, из которых 1 синий и 6 желтых. Энтропия правой группы равна $S_2 = -\frac{1}{7}\log_2{\frac{1}{7}}-\frac{6}{7}\log_2{\frac{6}{7}} \approx 0.6$. Как видим, энтропия уменьшилась в обеих группах по сравнению с начальным состоянием, хоть в левой и не сильно. Поскольку энтропия – по сути степень хаоса (или неопределенности) в системе, уменьшение энтропии называют приростом информации. Формально прирост информации (information gain, IG) при разбиении выборки по признаку ![$Q$](https://habrastorage.org/getpro/habr/formulas/3a5/e67/187/3a5e67187c94ffba1bacdbc00b809d08.svg) (в нашем примере это признак "$x \leq 12$") определяется как

$$
\Large IG(Q) = S_O - \sum_{i=1}^{q}\frac{N_i}{N}S_i,
$$
где ![$q$](https://habrastorage.org/getpro/habr/formulas/8f3/06f/830/8f306f830651d08b378d79f1e4432853.svg) – число групп после разбиения, ![$N_i$](https://habrastorage.org/getpro/habr/formulas/252/a50/991/252a50991302f6fa8310dfec2c1a4055.svg) – число элементов выборки, у которых признак ![$Q$](https://habrastorage.org/getpro/habr/formulas/3a5/e67/187/3a5e67187c94ffba1bacdbc00b809d08.svg) имеет ![$i$](https://habrastorage.org/getpro/habr/formulas/b87/c43/419/b87c4341953d9930499c99cfd4f7de89.svg)\-ое значение. В нашем случае после разделения получилось две группы (![$q = 2$](https://habrastorage.org/getpro/habr/formulas/9a8/bce/0f6/9a8bce0f634b3ebd541c207aa6496b9c.svg)) – одна из 13 элементов (![$N_1 = 13$](https://habrastorage.org/getpro/habr/formulas/732/5de/a8d/7325dea8d5899aa331e784a3be620096.svg)), вторая – из 7 (![$N_2 = 7$](https://habrastorage.org/getpro/habr/formulas/6fc/61e/02b/6fc61e02bd987482af66e6affd2cc569.svg)). Прирост информации получился

$$
\Large IG(x \leq 12) = S_0 - \frac{13}{20}S_1 - \frac{7}{20}S_2 \approx 0.16.
$$
Получается, разделив шарики на две группы по признаку "координата меньше либо равна 12", мы уже получили более упорядоченную систему, чем в начале. Продолжим деление шариков на группы до тех пор, пока в каждой группе шарики не будут одного цвета.

![](https://habrastorage.org/r/w1560/files/dae/a88/2b0/daea882b0a8e4ef4b23325c88f0353a1.png " ")

Для правой группы потребовалось всего одно дополнительное разбиение по признаку "координата меньше либо равна 18", для левой – еще три. Очевидно, энтропия группы с шариками одного цвета равна 0 (![$\log_2{1} = 0$](https://habrastorage.org/getpro/habr/formulas/0f0/221/4b5/0f02214b5cf75822a98c86051a6e2c42.svg)), что соответствует представлению, что группа шариков одного цвета – упорядоченная. 
В итоге мы построили дерево решений, предсказывающее цвет шарика по его координате. Отметим, что такое дерево решений может плохо работать для новых объектов (определения цвета новых шариков), поскольку оно идеально подстроилось под обучающую выборку (изначальные 20 шариков). Для классификации новых шариков лучше подойдет дерево с меньшим числом "вопросов", или разделений, пусть даже оно и не идеально разбивает по цветам обучающую выборку. Эту проблему, переобучение, мы еще рассмотрим далее.

  

### Алгоритм построения дерева

Можно убедиться в том, что построенное в предыдущем примере дерево является в некотором смысле оптимальным – потребовалось только 5 "вопросов" (условий на признак ![$x$](https://habrastorage.org/getpro/habr/formulas/4cc/fd4/32e/4ccfd432ea4f2a64f3a5c8c7378517af.svg)), чтобы "подогнать" дерево решений под обучающую выборку, то есть чтобы дерево правильно классифицировало любой обучающий объект. При других условиях разделения выборки дерево получится глубже.

В основе популярных алгоритмов построения дерева решений, таких как ID3 и C4.5, лежит принцип жадной максимизации прироста информации – на каждом шаге выбирается тот признак, при разделении по которому прирост информации оказывается наибольшим. Дальше процедура повторяется рекурсивно, пока энтропия не окажется равной нулю или какой-то малой величине (если дерево не подгоняется идеально под обучающую выборку во избежание переобучения). 

В разных алгоритмах применяются разные эвристики для "ранней остановки" или "отсечения", чтобы избежать построения переобученного дерева.

  

```python
def build(L):
    create node t
    if the stopping criterion is True:
        assign a predictive model to t
    else:
        Find the best binary split L = L_left + L_right
        t.left = build(L_left)
        t.right = build(L_right)
    return t  
```

  

### Другие критерии качества разбиения в задаче классификации

Мы разобрались в том, как понятие энтропии позволяет формализовать представление о качестве разбиения в дереве. Но это всего лишь эвристика, существуют и другие:

  

На практике ошибка классификации почти не используется, а неопределенность Джини и прирост информации работают почти одинаково.

  

В случае задачи бинарной классификации (![$p_+$](https://habrastorage.org/getpro/habr/formulas/f62/26c/189/f6226c189ced00b5d1eb4b3af675f6ea.svg) – вероятность объекта иметь метку +) энтропия и неопределенность Джини примут следующий вид:

![$ S = -p_+ \log_2{p_+} -p_- \log_2{p_-} = -p_+ \log_2{p_+} -(1 - p_{+}) \log_2{(1 - p_{+})};$](https://habrastorage.org/getpro/habr/formulas/013/071/8f2/0130718f28fc752bca12d2313ddaad1c.svg)

![$ G = 1 - p_+^2 - p_-^2 = 1 - p_+^2 - (1 - p_+)^2 = 2p_+(1-p_+).$](https://habrastorage.org/getpro/habr/formulas/dd2/f1a/91c/dd2f1a91c8ac59bdd9cc12a074703938.svg)

Когда мы построим графики этих двух функций от аргумента ![$p_+$](https://habrastorage.org/getpro/habr/formulas/f62/26c/189/f6226c189ced00b5d1eb4b3af675f6ea.svg), то увидим, что график энтропии очень близок к графику удвоенной неопределенности Джини, и поэтому на практике эти два критерия "работают" почти одинаково.

  

**Импорт библиотек**

```python
from __future__ import division, print_function
# отключим всякие предупреждения Anaconda
import warnings
warnings.filterwarnings('ignore')
import numpy as np
import pandas as pd
%matplotlib inline
import seaborn as sns
from matplotlib import pyplot as plt
```

  

**Отрисовка картинки**

```python
plt.rcParams['figure.figsize'] = (6,4)
xx = np.linspace(0,1,50)
plt.plot(xx, [2 * x * (1-x) for x in xx], label='gini')
plt.plot(xx, [4 * x * (1-x) for x in xx], label='2*gini')
plt.plot(xx, [-x * np.log2(x) - (1-x) * np.log2(1 - x)  for x in xx], label='entropy')
plt.plot(xx, [1 - max(x, 1-x) for x in xx], label='missclass')
plt.plot(xx, [2 - 2 * max(x, 1-x) for x in xx], label='2*missclass')
plt.xlabel('p+')
plt.ylabel('criterion')
plt.title('Критерии качества как функции от p+ (бинарная классификация)')
plt.legend();
```

![](https://habrastorage.org/r/w1560/files/a88/bc3/e18/a88bc3e185b246e088a4382e212e4473.png " ")

#### Пример

Рассмотрим пример применения дерева решений из библиотеки Scikit-learn для синтетических данных. Два класса будут сгенерированы из двух нормальных распределений с разными средними.

  

**Код для генерации данных**

```python
# первый класс
np.random.seed(7)
train_data = np.random.normal(size=(100, 2))
train_labels = np.zeros(100)

# добавляем второй класс
train_data = np.r_[train_data, np.random.normal(size=(100, 2), loc=2)]
train_labels = np.r_[train_labels, np.ones(100)]
```

Отобразим данные. Неформально, задача классификации в этом случае – построить какую-то "хорошую" границу, разделяющую 2 класса (красные точки от желтых). Если утрировать, то машинное обучение в этом случае сводится к тому, как выбрать хорошую разделяющую границу. Возможно, прямая будет слишком простой границей, а какая-то сложная кривая, огибающая каждую красную точку – будет слишком сложной и будем много ошибаться на новых примерах из того же распределения, из которого пришла обучающая выборка. Интуиция подсказывает, что хорошо на новых данных будет работать какая-то _гладкая_ граница, разделяющая 2 класса, или хотя бы просто прямая (в ![$n$](https://habrastorage.org/getpro/habr/formulas/35b/a56/5f3/35ba565f36734f3a55aa01ac67868762.svg)\-мерном случае – гиперплоскость).

  

**Отрисовка картинки**

```python
plt.rcParams['figure.figsize'] = (10,8)
plt.scatter(train_data[:, 0], train_data[:, 1], c=train_labels, s=100, 
cmap='autumn', edgecolors='black', linewidth=1.5);
plt.plot(range(-2,5), range(4,-3,-1));
```

![](https://habrastorage.org/r/w1560/files/987/707/6e8/9877076e87ac410b8e40eedc77a17a99.png " ")

Попробуем разделить эти два класса, обучив дерево решений. В дереве будем использовать параметр `max_depth`, ограничивающий глубину дерева. Визуализируем полученную границу разделения классов.

  

**Код для обучения дерева и отрисовки его разделяющей границы**

```python
from sklearn.tree import DecisionTreeClassifier

# Напишем вспомогательную функцию, которая будет возвращать решетку для дальнейшей визуализации.
def get_grid(data):
    x_min, x_max = data[:, 0].min() - 1, data[:, 0].max() + 1
    y_min, y_max = data[:, 1].min() - 1, data[:, 1].max() + 1
    return np.meshgrid(np.arange(x_min, x_max, 0.01), np.arange(y_min, y_max, 0.01))

# параметр min_samples_leaf указывает, при каком минимальном количестве
# элементов в узле он будет дальше разделяться
clf_tree = DecisionTreeClassifier(criterion='entropy', max_depth=3, random_state=17)

# обучаем дерево
clf_tree.fit(train_data, train_labels)

# немного кода для отображения разделяющей поверхности
xx, yy = get_grid(train_data)
predicted = clf_tree.predict(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)
plt.pcolormesh(xx, yy, predicted, cmap='autumn')
plt.scatter(train_data[:, 0], train_data[:, 1], c=train_labels, s=100, 
cmap='autumn', edgecolors='black', linewidth=1.5);
```

![](https://habrastorage.org/r/w1560/files/560/d97/0ca/560d970caaf749fda34bd8417160ed7e.png " ")

А как выглядит само построенное дерево? Видим, что дерево "нарезает" пространство на 7 прямоугольников (в дереве 7 листьев). В каждом таком прямоугольнике прогноз дерева будет константным, по превалированию объектов того или иного класса.

  

**Код для отображения дерева**

```python
# используем .dot формат для визуализации дерева
from sklearn.tree import export_graphviz
export_graphviz(clf_tree, feature_names=['x1', 'x2'], 
out_file='../../img/small_tree.dot', filled=True)
# для этого понадобится библиотека pydot (pip install pydot)
!dot -Tpng '../../img/small_tree.dot' -o '../../img/small_tree.png'
```

![](https://habrastorage.org/r/w1560/files/bf1/1fe/490/bf11fe49088f428996a27b0d2d2a6592.png " ")

Как "читается" такое дерево?

В начале было 200 объектов, 100 — одного класса и 100 – другого. Энтропия начального состояния была максимальной – 1. Затем было сделано разбиение объектов на 2 группы в зависимости от сравнения признака ![$x_1$](https://habrastorage.org/getpro/habr/formulas/827/6a3/55d/8276a355d254a55b0c1ba5d9cba3ff61.svg) со значением ![$0.3631$](https://habrastorage.org/getpro/habr/formulas/51f/a18/788/51fa187885bc36f241d577d436d0d933.svg) (найдите этот участок границы на рисунке выше, до дерева). При этом энтропия и в левой, и в правой группе объектов уменьшилась. И так далее, дерево строится до глубины 3. При такой визуализации чем больше объектов одного класса, тем цвет вершины ближе к темно-оранжевому и, наоборот, чем больше объектов второго класса, тем ближе цвет к темно-синему. В начале объектов одного класса поровну, поэтому корневая вершина дерева – белого цвета.

  

### Как дерево решений работает с количественными признаками

Допустим, в выборке имеется количественный признак "Возраст", имеющий много уникальных значений. Дерево решений будет искать лучшее (по критерию типа прироста информации) разбиение выборки, проверяя бинарные признаки типа "Возраст < 17", "Возраст < 22.87" и т.д. Но что если таких "нарезаний" возраста слишком много? А что если есть еще количественный признак "Зарплата", и зарплату тоже можно "нарезать" большим числом способов? Получается слишком много бинарных признаков для выбора лучшего на каждом шаге построения дерева. Для решения этой проблемы применяют эвристики для ограничения числа порогов, с которыми мы сравниваем количественный признак.

Рассмотрим это на игрушечном примере. Пусть имеется следующая выборка:

![](https://habrastorage.org/r/w1560/files/5e0/213/081/5e0213081b034e63aa76e2086e521519.png " ")

Отсортируем ее по возрастанию возраста.

![](https://habrastorage.org/r/w1560/files/10b/d4a/dbf/10bd4adbf3804c3bbd9443cbd2ac7539.png " ")

Обучим на этих данных дерево решений (без ограничения глубины) и посмотрим на него.

 

**Код для обучения и отрисовки дерева**

```python
age_tree = DecisionTreeClassifier(random_state=17)
age_tree.fit(data['Возраст'].values.reshape(-1, 1), data['Невозврат кредита'].values)

export_graphviz(age_tree, feature_names=['Возраст'], 
out_file='../../img/age_tree.dot', filled=True)
!dot -Tpng '../../img/age_tree.dot' -o '../../img/age_tree.png'
```

На картинке ниже видим, что дерево задействовало 5 значений, с которыми сравнивается возраст: 43.5, 19, 22.5, 30 и 32 года. Если приглядеться, то это аккурат средние значения между возрастами, при которых целевой класс "меняется" с 1 на 0 или наоборот. Сложная фраза, поэтому пример: 43.5 – это среднее между 38 и 49 годами, клиент, которому 38 лет не вернул кредит, а тот, которому 49 – вернул. Аналогично, 19 лет – среднее между 18 и 20 годами. То есть в качестве порогов для "нарезания" количественного признака, дерево "смотрит" на те значения, при которых целевой класс меняет свое значение.

Подумайте, почему не имеет смысла в данном случае рассматривать признак "Возраст < 17.5".

![](https://habrastorage.org/r/w1560/files/10b/d4a/dbf/10bd4adbf3804c3bbd9443cbd2ac7539.png " ")

![](https://habrastorage.org/r/w1560/files/1dc/56d/fce/1dc56dfcee144e0db7043f6752d40360.png " ")

Рассмотрим пример посложнее: добавим признак "Зарплата" (тыс. рублей/месяц).

![](https://habrastorage.org/r/w1560/files/dc6/073/7bd/dc60737bd1c0488f8c8b4df02d8c621b.png " ")

Если отсортировать по возрасту, то целевой класс ("Невозврат кредита") меняется (с 1 на 0 или наоборот) 5 раз. А если отсортировать по зарплате – то 7 раз. Как теперь дерево будет выбирать признаки? Посмотрим.

![](https://habrastorage.org/r/w1560/files/67f/77a/2fa/67f77a2fa24441f198c2deccb1d8c9c3.png " ")

![](https://habrastorage.org/r/w1560/files/cee/a9c/d76/ceea9cd76cee4fe2a8fde36be1af3e2d.png " ")

**Код для обучения и отрисовки дерева**

```python
age_sal_tree = DecisionTreeClassifier(random_state=17)
age_sal_tree.fit(data2[['Возраст', 'Зарплата']].values, data2['Невозврат кредита'].values);

export_graphviz(age_sal_tree, feature_names=['Возраст', 'Зарплата'], 
out_file='../../img/age_sal_tree.dot', filled=True)
!dot -Tpng '../../img/age_sal_tree.dot' -o '../../img/age_sal_tree.png'
```

![](https://habrastorage.org/r/w1560/files/4a6/c17/1e0/4a6c171e06324bb2afee3c76eb6bb226.png " ")

Видим, что в дереве задействованы как разбиения по возрасту, так и по зарплате. Причем пороги, с которыми сравниваются признаки: 43.5 и 22.5 года – для возраста и 95 и 30.5 тыс. руб/мес – для зарплаты. И опять можно заметить, что 95 тыс. – это среднее между 88 и 102, при этом человек с зарплатой 88 оказался "плохим", а с 102 – "хорошим". То же самое для 30.5 тыс. То есть перебирались сравнения зарплаты и возраста не со всеми возможными значениями, а только с несколькими. А почему в дереве оказались именно эти признаки? Потому что по ним разбиения оказались лучше (по критерию неопределенности Джини).

**Вывод:** самая простая эвристика для обработки количественных признаков в дереве решений: количественный признак сортируется по возрастанию, и в дереве проверяются только те пороги, при которых целевой признак меняет значение. Звучит не очень строго, но надеюсь, я донес смысл с помощью игрушечных примеров.

Дополнительно, когда в данных много количественных признаков, и у каждого много уникальных значений, могут отбираться не все пороги, описанные выше, а только топ-N, дающих максимальный прирост все того же критерия. То есть, по сути, для каждого порога строится дерево глубины 1, считается насколько снизилась энтропия (или неопределенность Джини) и выбираются только лучшие пороги, с которыми стоит сравнивать количественный признак.

Для иллюстрации: при разбиении по признаку "Зарплата ![$\leq$](https://habrastorage.org/getpro/habr/formulas/ad6/1d2/503/ad61d2503db2ae8d68f3569fddf3b589.svg) 34.5" в левой подгруппе энтропия 0 (все клиенты "плохие"), а в правой – 0.954 (3 "плохих" и 5 "хороших", можете проверить, 1 часть домашнего задания будет как раз на то, чтоб разобраться досконально с построением деревьев). Прирост информации получается примерно 0.3. 

А при разбиении по признаку "Зарплата ![$\leq$](https://habrastorage.org/getpro/habr/formulas/ad6/1d2/503/ad61d2503db2ae8d68f3569fddf3b589.svg) 95" в левой подгруппе энтропия 0.97 (6 "плохих" и 4 "хороших"), а в правой – 0 (всего один объект). Прирост информации получается примерно 0.11. 

Посчитав таким образом прирост информации для каждого разбиения, можно предварительно, до построения большого дерева (по всем признакам) отобрать пороги, с которыми будет сравниваться каждый количественный признак.

Еще примеры дискретизации количественных признаков можно посмотреть в постах, подобных [этому](http://kevinmeurer.com/a-simple-guide-to-entropy-based-discretization/) или [этому](http://clear-lines.com/blog/post/Discretizing-a-continuous-variable-using-Entropy.aspx). Одна из самых известных научных статей на эту тему – "On the handling of continuous-valued attributes in decision tree generation" (U.M. Fayyad. K.B. Irani, "Machine Learning", 1992).

  

### Основные параметры дерева

В принципе дерево решений можно построить до такой глубины, чтоб в каждом листе был ровно один объект. Но на практике это не делается (если строится только одно дерево) из-за того, что такое дерево будет _переобученным_ – оно слишком настроится на обучающую выборку и будет плохо работать на прогноз на новых данных. Где-то внизу дерева, на большой глубине будут появляться разбиения по менее важным признакам (например, приехал ли клиент из Саратова или Костромы). Если утрировать, может оказаться так, что из всех 4 клиентов, пришедших в банк за кредитом в зеленых штанах, никто не вернул кредит. Но мы не хотим, чтобы наша модель классификации порождала такие специфичные правила.

Есть два исключения, ситуации, когда деревья строятся до максимальной глубины:

-   Случайный лес (композиция многих деревьев) усредняет ответы деревьев, построенных до максимальной глубины (почему стоит делать именно так, разберемся позже)
-   Стрижка дерева (_pruning_). При таком подходе дерево сначала строится до максимальной глубины, потом постепенно, снизу вверх, некоторые вершины дерева убираются за счет сравнения по качеству дерева с данным разбиением и без него (сравнение проводится с помощью _кросс-валидации_, о которой чуть ниже). Подробнее можно почитать в материалах [репозитория](https://github.com/esokolov/ml-course-hse) Евгения Соколова.

Картинка ниже – пример разделяющей границы, построенной переобученным деревом.

![](https://habrastorage.org/r/w1560/files/f9f/3b5/133/f9f3b5133bae460ba96ab7e546155b1d.png " ")

Основные способы борьбы с переобучением в случае деревьев решений:

-   искусственное ограничение глубины или минимального числа объектов в листе: построение дерева просто в какой-то момент прекращается;
-   стрижка дерева

  

### Класс DecisionTreeClassifier в Scikit-learn

Основные параметры класса [`sklearn.tree.DecisionTreeClassifier`](http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html):

-   `max_depth` – максимальная глубина дерева
-   `max_features` — максимальное число признаков, по которым ищется лучшее разбиение в дереве (это нужно потому, что при большом количестве признаков будет "дорого" искать лучшее (по критерию типа прироста информации) разбиение среди _всех_ признаков)
-   `min_samples_leaf` – минимальное число объектов в листе. У этого параметра есть понятная интерпретация: скажем, если он равен 5, то дерево будет порождать только те классифицирующие правила, которые верны как минимум для 5 объектов

Параметры дерева надо настраивать в зависимости от входных данных, и делается это обычно с помощью _кросс-валидации_, про нее чуть ниже.

  

### Дерево решений в задаче регрессии

При прогнозировании количественного признака идея построения дерева остается та же, но меняется критерий качества:

- Дисперсия вокруг среднего: ![$\Large D = \frac{1}{\ell} \sum\limits_{i =1}^{\ell} (y_i - \frac{1}{\ell} \sum\limits_{i =1}^{\ell} y_i)^2, $](https://habrastorage.org/getpro/habr/formulas/08c/57f/a86/08c57fa86cf8817d4dd40a37b67aa24d.svg)
    где ![$\ell$](https://habrastorage.org/getpro/habr/formulas/772/376/76e/77237676e7097bb65d5dc97fce3ff8d3.svg) – число объектов в листе, ![$y_i$](https://habrastorage.org/getpro/habr/formulas/0ca/673/9ff/0ca6739fff04e5b6f01b2d9cd8bcfa21.svg) – значения целевого признака. Попросту говоря, минимизируя дисперсию вокруг среднего, мы ищем признаки, разбивающие выборку таким образом, что значения целевого признака в каждом листе примерно равны.


#### Пример

Сгенерируем данные, распределенные вокруг функции ![$f(x) = e^{-x ^ 2} + 1.5 * e^{-(x - 2) ^ 2}$](https://habrastorage.org/getpro/habr/formulas/2fc/d29/0cc/2fcd290cc0694fbd65fc0b26f9491ace.svg) c некоторым шумом, обучим на них дерево решений и изобразим, какие прогнозы делает дерево.

  

**Код**

```python
n_train = 150        
n_test = 1000       
noise = 0.1

def f(x):
    x = x.ravel()
    return np.exp(-x ** 2) + 1.5 * np.exp(-(x - 2) ** 2)

def generate(n_samples, noise):
    X = np.random.rand(n_samples) * 10 - 5
    X = np.sort(X).ravel()
    y = np.exp(-X ** 2) + 1.5 * np.exp(-(X - 2) ** 2) + \
    np.random.normal(0.0, noise, n_samples)
    X = X.reshape((n_samples, 1))
    return X, y

X_train, y_train = generate(n_samples=n_train, noise=noise)
X_test, y_test = generate(n_samples=n_test, noise=noise)

from sklearn.tree import DecisionTreeRegressor

reg_tree = DecisionTreeRegressor(max_depth=5, random_state=17)

reg_tree.fit(X_train, y_train)
reg_tree_pred = reg_tree.predict(X_test)

plt.figure(figsize=(10, 6))
plt.plot(X_test, f(X_test), "b")
plt.scatter(X_train, y_train, c="b", s=20)
plt.plot(X_test, reg_tree_pred, "g", lw=2)
plt.xlim([-5, 5])
plt.title("Decision tree regressor, MSE = %.2f" % np.sum((y_test - reg_tree_pred) ** 2))
plt.show()
```

![](https://habrastorage.org/r/w1560/files/856/c8b/9ad/856c8b9ad9094250a9d23e91e6f74e97.png " ")

Видим, что дерево решений аппроксимирует зависимость в данных кусочно-постоянной функцией.

  

## Метод ближайших соседей

Метод ближайших соседей (k Nearest Neighbors, или kNN) — тоже очень популярный метод классификации, также иногда используемый в задачах регрессии. Это, наравне с деревом решений, один из самых понятных подходов к классификации. На уровне интуиции суть метода такова: посмотри на соседей, какие преобладают, таков и ты. Формально основой метода является гипотеза компактности: если метрика расстояния между примерами введена достаточно удачно, то схожие примеры гораздо чаще лежат в одном классе, чем в разных.

Согласно методу ближайших соседей, тестовый пример (зеленый шарик) будет отнесен к классу "синие", а не "красные".

![](https://habrastorage.org/r/w1560/files/4b8/000/4ab/4b80004ab2414944802677e2e1cb1b76.png " ")

Например, если не знаешь, какой тип товара указать в объявлении для Bluetooth-гарнитуры, можешь найти 5 похожих гарнитур, и если 4 из них отнесены к категории "Аксессуары", и только один — к категории "Техника", то здравый смысл подскажет для своего объявления тоже указать категорию "Аксессуары".

Для классификации каждого из объектов тестовой выборки необходимо последовательно выполнить следующие операции:

- Вычислить расстояние до каждого из объектов обучающей выборки;
- Отобрать ![$k$](https://habrastorage.org/getpro/habr/formulas/fce/525/2bd/fce5252bde946816c2cf744d932890f7.svg) объектов обучающей выборки, расстояние до которых минимально;
- Класс классифицируемого объекта — это класс, наиболее часто встречающийся среди ![$k$](https://habrastorage.org/getpro/habr/formulas/fce/525/2bd/fce5252bde946816c2cf744d932890f7.svg) ближайших соседей.

Под задачу регрессии метод адаптируется довольно легко – на 3 шаге возвращается не метка, а число – среднее (или медианное) значение целевого признака среди соседей.

Примечательное свойство такого подхода – его ленивость. Это значит, что вычисления начинаются только в момент классификации тестового примера, а заранее, только при наличии обучающих примеров, никакая модель не строится. В этом отличие, например, от ранее рассмотренного дерева решений, где сначала на основе обучающей выборки строится дерево, а потом относительно быстро происходит классификация тестовых примеров.

Стоит отметить, что метод ближайших соседей – хорошо изученный подход (в машинном обучении, эконометрике и статистике больше известно, наверное, только про линейную регрессию). Для метода ближайших соседей существует немало важных теорем, утверждающих, что на "бесконечных" выборках это оптимальный метод классификации. Авторы классической книги "The Elements of Statistical Learning" считают kNN теоретически идеальным алгоритмом, применимость которого просто ограничена вычислительными возможностями и проклятием размерностей.

  

### Метод ближайших соседей в реальных задачах

-   В чистом виде kNN может послужить хорошим стартом (baseline) в решении какой-либо задачи;
-   В соревнованиях Kaggle kNN часто используется для построения мета-признаков (прогноз kNN подается на вход прочим моделям) или в стекинге/блендинге;
-   Идея ближайшего соседа расширяется и на другие задачи, например, в рекомендательных системах простым начальным решением может быть рекомендация какого-то товара (или услуги), популярного среди _ближайших соседей_ человека, которому хотим сделать рекомендацию;
-   На практике для больших выборок часто пользуются _приближенными_ методами поиска ближайших соседей. [Вот](https://www.youtube.com/watch?v=UUm4MOyVTnE) лекция Артема Бабенко про эффективные алгоритмы поиска ближайших соседей среди миллиардов объектов в пространствах высокой размерности (поиск по картинкам). Также известны открытые библиотеки, в которых реализованы такие алгоритмы, спасибо компании Spotify за ее библиотеку [Annoy](https://github.com/spotify/annoy).

Качество классификации/регрессии методом ближайших соседей зависит от нескольких параметров:

-   число соседей
-   метрика расстояния между объектами (часто используются метрика Хэмминга, евклидово расстояние, косинусное расстояние и расстояние Минковского). Отметим, что при использовании большинства метрик значения признаков надо масштабировать. Условно говоря, чтобы признак "Зарплата" с диапазоном значений до 100 тысяч не вносил больший вклад в расстояние, чем "Возраст" со значениями до 100.
-   веса соседей (соседи тестового примера могут входить с разными весами, например, чем дальше пример, тем с меньшим коэффициентом учитывается его "голос")

  

### Класс KNeighborsClassifier в Scikit-learn

Основные параметры класса sklearn.neighbors.KNeighborsClassifier:

-   weights: "uniform" (все веса равны), "distance" (вес обратно пропорционален расстоянию до тестового примера) или другая определенная пользователем функция
-   algorithm (опционально): "brute", "ball\_tree", "KD\_tree", или "auto". В первом случае ближайшие соседи для каждого тестового примера считаются перебором обучающей выборки. Во втором и третьем — расстояние между примерами хранятся в дереве, что ускоряет нахождение ближайших соседей. В случае указания параметра "auto" подходящий способ нахождения соседей будет выбран автоматически на основе обучающей выборки.
-   leaf\_size (опционально): порог переключения на полный перебор в случае выбора BallTree или KDTree для нахождения соседей
-   metric: "minkowski", "manhattan", "euclidean", "chebyshev" и другие

  

## Выбор параметров модели и кросс-валидация

Главная задача обучаемых алгоритмов – их способность _обобщаться_, то есть хорошо работать на новых данных. Поскольку на новых данных мы сразу не можем проверить качество построенной модели (нам ведь надо для них сделать прогноз, то есть истинных значений целевого признака мы для них не знаем), то надо пожертвовать небольшой порцией данных, чтоб на ней проверить качество модели.

Чаще всего это делается одним из 2 способов:

-   отложенная выборка (_held-out/hold-out set_). При таком подходе мы оставляем какую-то долю обучающей выборки (как правило от 20% до 40%), обучаем модель на остальных данных (60-80% исходной выборки) и считаем некоторую метрику качества модели (например, самое простое – долю правильных ответов в задаче классификации) на отложенной выборке.
-   кросс-валидация (_cross-validation_, на русский еще переводят как скользящий или перекрестный контроль). Тут самый частый случай – K-fold кросс-валидация

![](https://habrastorage.org/r/w1560/files/b1d/706/e6c/b1d706e6c9df49c297b6152878a2d03f.png " ")

Тут модель обучается ![$K$](https://habrastorage.org/getpro/habr/formulas/117/5ef/b8b/1175efb8bee3e7b48fb17482fa0cd6e7.svg) раз на разных (![$K-1$](https://habrastorage.org/getpro/habr/formulas/dd3/202/7d3/dd32027d3d021ee185e2839877e3d2c4.svg)) подвыборках исходной выборки (белый цвет), а проверяется на одной подвыборке (каждый раз на разной, оранжевый цвет). 

Получаются ![$K$](https://habrastorage.org/getpro/habr/formulas/117/5ef/b8b/1175efb8bee3e7b48fb17482fa0cd6e7.svg) оценок качества модели, которые обычно усредняются, выдавая среднюю оценку качества классификации/регрессии на кросс-валидации.

Кросс-валидация дает лучшую по сравнению с отложенной выборкой оценку качества модели на новых данных. Но кросс-валидация вычислительно дорогостоящая, если данных много.

Кросс-валидация – очень важная техника в машинном обучении (применяемая также в статистике и эконометрике), с ее помощью выбираются гиперпараметры моделей, сравниваются модели между собой, оценивается полезность новых признаков в задаче и т.д. Более подробно можно почитать, например, [тут](https://sebastianraschka.com/blog/2016/model-evaluation-selection-part1.html) у Sebastian Raschka или в любом классическом учебнике по машинному (статистическому) обучению

  

## Примеры применения

  

### Деревья решений и метод ближайших соседей в задаче прогнозирования оттока клиентов телеком-оператора

Считаем данные в DataFrame и проведем предобработку. Штаты пока сохраним в отдельный объект Series, но удалим из датафрейма. Первую модель будем обучать без штатов, потом посмотрим, помогают ли они.

  

**Считывание и предобработка данных**

```python
# DATA_PATH = "https://raw.githubusercontent.com/Yorko/mlcourse.ai/main/data/"
# df = pd.read_csv(DATA_PATH + "telecom_churn.csv")

df = pd.read_csv('../../data/telecom_churn.csv')

df['International plan'] = pd.factorize(df['International plan'])[0]
df['Voice mail plan'] = pd.factorize(df['Voice mail plan'])[0]
df['Churn'] = df['Churn'].astype('int')
states = df['State']
y = df['Churn']
df.drop(['State', 'Churn'], axis=1, inplace=True)
```

![](https://habrastorage.org/r/w1560/files/978/022/6a8/9780226a800b4a1da342daaa966b4a0e.png " ")

Выделим 70% выборки (X\_train, y\_train) под обучение и 30% будут отложенной выборкой (X\_holdout, y\_holdout). отложенная выборка никак не будет участвовать в настройке параметров моделей, на ней мы в конце, после этой настройки, оценим качество полученной модели. Обучим 2 модели – дерево решений и kNN, пока не знаем, какие параметры хороши, поэтому наугад: глубину дерева берем 5, число ближайших соседей – 10.

  

**Код**

```python
from sklearn.model_selection import train_test_split, StratifiedKFold
from sklearn.neighbors import KNeighborsClassifier

X_train, X_holdout, y_train, y_holdout = train_test_split(df.values, y, test_size=0.3,
random_state=17)

tree = DecisionTreeClassifier(max_depth=5, random_state=17)
knn = KNeighborsClassifier(n_neighbors=10)

tree.fit(X_train, y_train)
knn.fit(X_train, y_train)
```

Качество прогнозов будем проверять с помощью простой метрики – доли правильных ответов. Сделаем прогнозы для отложенной выборки. Дерево решений справилось лучше: доля правильных ответов около 94% против 88% у kNN. Но это мы пока выбирали параметры наугад.

  

**Код для оценки моделей**

```python
from sklearn.metrics import accuracy_score

tree_pred = tree.predict(X_holdout)
accuracy_score(y_holdout, tree_pred) # 0.94
```

  

```python
knn_pred = knn.predict(X_holdout)
accuracy_score(y_holdout, knn_pred) # 0.88
```

Теперь настроим параметры дерева на кросс-валидации. Настраивать будем максимальную глубину и максимальное используемое на каждом разбиении число признаков. Суть того, как работает GridSearchCV: для каждой уникальной пары значений параметров `max_depth` и `max_features` будет проведена 5-кратная кросс-валидация и выберется лучшее сочетание параметров.

  

**Настройка параметров моделей**

```python
from sklearn.model_selection import GridSearchCV, cross_val_score
```

  

```python
tree_params = {'max_depth': range(1,11),
'max_features': range(4,19)}
```

  

```python
tree_grid = GridSearchCV(tree, tree_params,
cv=5, n_jobs=-1,
verbose=True)
```

  

```python
tree_grid.fit(X_train, y_train)
```

Лучшее сочетание параметров и соответствующая средняя доля правильных ответов на кросс-валидации:

  

```python
tree_grid.best_params_
```

{'max\_depth': 6, 'max\_features': 17}

  

```python
tree_grid.best_score_
```

0.94256322331761677

  

```python
accuracy_score(y_holdout, tree_grid.predict(X_holdout))
```

0.94599999999999995

Теперь попробуем настроить число соседей в алгоритме kNN.

  

```python
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
```

  

```python
knn_pipe = Pipeline([('scaler', StandardScaler()), ('knn', KNeighborsClassifier(n_jobs=-1))])
```

  

```python
knn_params = {'knn__n_neighbors': range(1, 10)}
```

  

```python
knn_grid = GridSearchCV(knn_pipe, knn_params,
cv=5, n_jobs=-1,
verbose=True)
```

  

```python
knn_grid.fit(X_train, y_train)
```

  

```python
knn_grid.best_params_, knn_grid.best_score_
```

({'knn\_\_n\_neighbors': 7}, 0.88598371195885128)

  

```python
accuracy_score(y_holdout, knn_grid.predict(X_holdout))
```

0.89000000000000001

В этом примере дерево показало себя лучше, чем метод ближайших соседей: 94.2% правильных ответов на кросс-валидации и 94.6% на отложенной выборке против 88.6% / 89% для kNN. Более того, в данной задаче дерево проявляет себя очень хорошо, и даже случайный лес (который пока представляем просто как кучу деревьев, которые вместе работают почему-то намного лучше, чем одно дерево) в этом примере показывает долю правильных ответов не намного выше (95.1% на кросс-валидации и 95.3% –на отложенной выборке), а обучается намного дольше.

  

**Код для обучения и настройки случайного леса**

```python
from sklearn.ensemble import RandomForestClassifier

forest = RandomForestClassifier(n_estimators=100, n_jobs=-1, random_state=17)
print(np.mean(cross_val_score(forest, X_train, y_train, cv=5))) # 0.949
```

  

```python
forest_params = {'max_depth': range(1,11),
'max_features': range(4,19)}
```

  

```python
forest_grid = GridSearchCV(forest, forest_params,
cv=5, n_jobs=-1,
verbose=True)
```

  

```python
forest_grid.fit(X_train, y_train)
```

  

```python
forest_grid.best_params_, forest_grid.best_score_ # ({'max_depth': 9, 'max_features': 6}, 0.951)
```

  

```python
accuracy_score(y_holdout, forest_grid.predict(X_holdout)) # 0.953
```

Нарисуем получившееся дерево. Из-за того, что оно не совсем игрушечное (максимальная глубина – 6), картинка получается уже не маленькой, но по дереву можно "прогуляться", если отдельно открыть рисунок.

  

**Код для отрисовки дерева**

```python
export_graphviz(tree_grid.best_estimator_, feature_names=df.columns, 
out_file='../../img/churn_tree.dot', filled=True)
!dot -Tpng '../../img/churn_tree.dot' -o '../../img/churn_tree.png'
```

![](https://habrastorage.org/r/w1560/files/b52/84b/4db/b5284b4dbf994192af92808a628b4685.png " ")

### Сложный случай для деревьев решений

В продолжение обсуждения плюсов и минусов обсуждаемых методов приведем очень простой пример задачи классификации, с которым дерево справляется, но делает все как-то "сложнее", чем хотелось бы. Создадим множество точек на плоскости (2 признака), каждая точка будет относиться к одному из классов (+1, красные, или -1 – желтые). Если смотреть на это как на задачу классификации, то вроде все очень просто – классы разделяются прямой.

  

**Код для генерации данных и картинки**

```python
def form_linearly_separable_data(n=500, x1_min=0, x1_max=30, x2_min=0, x2_max=30):
    data, target = [], []
    for i in range(n):
        x1, x2 = np.random.randint(x1_min, x1_max), np.random.randint(x2_min, x2_max)

        if np.abs(x1 - x2) > 0.5:
            data.append([x1, x2])
            target.append(np.sign(x1 - x2))
    return np.array(data), np.array(target)

X, y = form_linearly_separable_data()

plt.scatter(X[:, 0], X[:, 1], c=y, cmap='autumn', edgecolors='black');
```

![](https://habrastorage.org/r/w1560/files/efe/630/812/efe6308122d24681a635fdf8a6d361d9.png " ")

Однако дерево решений строит уж больно сложную границу и само по себе оказывается глубоким. Кроме того, представьте, как плохо дерево будет обобщаться на пространство вне представленного квадрата ![$30 \times 30$](https://habrastorage.org/getpro/habr/formulas/9f7/92a/4be/9f792a4be05140ddff968c7ca7462d81.svg), обрамляющего обучающую выборку.

  

**Код для отрисовки разделяющей поверхности, которую строит дерево**

```python
tree = DecisionTreeClassifier(random_state=17).fit(X, y)

xx, yy = get_grid(X, eps=.05)
predicted = tree.predict(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)
plt.pcolormesh(xx, yy, predicted, cmap='autumn')
plt.scatter(X[:, 0], X[:, 1], c=y, s=100, 
cmap='autumn', edgecolors='black', linewidth=1.5)
plt.title('Easy task. Decision tree compexifies everything');
```

![](https://habrastorage.org/r/w1560/files/004/5a7/9a2/0045a79a2b1c4c378cdb3fb1e80b1de8.png " ")

Вот такая сложная конструкция, хотя решение (хорошая разделяющая поверхность) – это всего лишь прямая ![$x_1 = x_2$](https://habrastorage.org/getpro/habr/formulas/812/bc9/fdf/812bc9fdfe2a9b868be4ec9633b959e7.svg).

  

**Код для отрисовки дерева**

```python
export_graphviz(tree, feature_names=['x1', 'x2'], 
out_file='../../img/deep_toy_tree.dot', filled=True)
!dot -Tpng '../../img/deep_toy_tree.dot' -o '../../img/deep_toy_tree.png'
```

![](https://habrastorage.org/r/w1560/files/077/436/c6b/077436c6b10044b8a7d673c6400798f0.png " ")

Метод одного ближайшего соседа здесь справляется вроде лучше дерева, но все же не так хорошо, как линейный классификатор (наша следующая тема).

  

**Код для отрисовки разделяющей поверхности, которую строит kNN**

```python
knn = KNeighborsClassifier(n_neighbors=1).fit(X, y)

xx, yy = get_grid(X, eps=.05)
predicted = knn.predict(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)
plt.pcolormesh(xx, yy, predicted, cmap='autumn')
plt.scatter(X[:, 0], X[:, 1], c=y, s=100, 
cmap='autumn', edgecolors='black', linewidth=1.5);
plt.title('Easy task, kNN. Not bad');
```

![](https://habrastorage.org/r/w1560/files/998/ad6/80c/998ad680c23e482d90193066059ec94c.png " ")

### Деревья решений и метод ближайших соседей в задаче распознавания рукописных цифр MNIST

Теперь посмотрим на описанные 2 алгоритма в реальной задаче. Используем "встроенные" в `sklearn` данные по рукописным цифрам. Эта задача будет примером, когда метод ближайших соседей работает на удивление хорошо.

Картинки здесь представляются матрицей 8 x 8 (интенсивности белого цвета для каждого пикселя). Далее эта матрица "разворачивается" в вектор длины 64, получается признаковое описание объекта.

Нарисуем несколько рукописных цифр, видим, что они угадываются.

  

**Загрузка данных и отрисовка нескольких цифр**

```python
from sklearn.datasets import load_digits

data = load_digits()
X, y = data.data, data.target

X[0,:].reshape([8,8])
```

array(\[\[ 0., 0., 5., 13., 9., 1., 0., 0.\],  
\[ 0., 0., 13., 15., 10., 15., 5., 0.\],  
\[ 0., 3., 15., 2., 0., 11., 8., 0.\],  
\[ 0., 4., 12., 0., 0., 8., 8., 0.\],  
\[ 0., 5., 8., 0., 0., 9., 8., 0.\],  
\[ 0., 4., 11., 0., 1., 12., 7., 0.\],  
\[ 0., 2., 14., 5., 10., 12., 0., 0.\],  
\[ 0., 0., 6., 13., 10., 0., 0., 0.\]\])

  

```python
f, axes = plt.subplots(1, 4, sharey=True, figsize=(16,6))
for i in range(4):
axes[i].imshow(X[i,:].reshape([8,8]));
```

![](https://habrastorage.org/r/w1560/files/856/119/828/8561198285a542fcace86e5939905ff5.png " ")

Далее проведем ровно такой же эксперимент, как и в прошлой задаче, только диапазоны изменения настраиваемых параметров будут немного другие.

  

**Настройка DT и kNN на данных MNIST**

Выделим 70% выборки (X\_train, y\_train) под обучение и 30% будут отложенной выборкой (X\_holdout, y\_holdout). отложенная выборка никак не будет участвовать в настройке параметров моделей, на ней мы в конце, после этой настройки, оценим качество полученной модели.

  

```python
X_train, X_holdout, y_train, y_holdout = train_test_split(X, y, test_size=0.3,
random_state=17)
```

Обучим дерево решений и kNN, опять параметры пока наугад берем.

  

```python
tree = DecisionTreeClassifier(max_depth=5, random_state=17)
knn = KNeighborsClassifier(n_neighbors=10)

tree.fit(X_train, y_train)
knn.fit(X_train, y_train)
```

Сделаем прогнозы для отложенной выборки. Видим, что метод ближайших соседей справился намного лучше. Но это мы пока выбирали параметры наугад.

  

```python
tree_pred = tree.predict(X_holdout)
knn_pred = knn.predict(X_holdout)
accuracy_score(y_holdout, knn_pred), accuracy_score(y_holdout, tree_pred) # (0.97, 0.666)
```

Теперь так же, как раньше настроим параметры моделей на кросс-валидации, только учтем, что признаков сейчас больше, чем в прошлой задаче — 64.

  

```python
tree_params = {'max_depth': [1, 2, 3, 5, 10, 20, 25, 30, 40, 50, 64],
'max_features': [1, 2, 3, 5, 10, 20 ,30, 50, 64]}

tree_grid = GridSearchCV(tree, tree_params,
cv=5, n_jobs=-1,
verbose=True)

tree_grid.fit(X_train, y_train)
```

Лучшее сочетание параметров и соответствующая средняя доля правильных ответов на кросс-валидации:

  

```python
tree_grid.best_params_, tree_grid.best_score_ # ({'max_depth': 20, 'max_features': 64}, 0.844)
```

Это уже не 66%, но и не 97%. Метод ближайших соседей на этом наборе данных работает лучше. В случае одного ближайшего соседа на кросс-валидации достигается почти 99% угадываний.

  

```python
np.mean(cross_val_score(KNeighborsClassifier(n_neighbors=1), X_train, y_train, cv=5)) # 0.987
```

Обучим на этих же данных случайный лес, он на большинстве выборок работает лучше, чем метод ближайших соседей. Но сейчас у нас исключение.

  

```python
np.mean(cross_val_score(RandomForestClassifier(random_state=17), X_train, y_train, cv=5)) # 0.935
```

Вы будете правы, если возразите, что мы тут не настраивали параметры RandomForestClassifier, но даже с настройкой доля правильных ответов не достигает 98%, как для у метода одного ближайшего соседа.

Результаты эксперимента 
_(Обозначения: CV и Holdout– средние доли правильных ответов модели на кросс-валидации и отложенной выборке соот-но. DT – дерево решений, kNN – метод ближайших соседей, RF – случайный лес)_

| algo\eval | CV    | Holdout |
| --------- | ----- | ------- |
| **DT**    | 0.844 | 0.838   |
| **kNN**   | 0.987 | 0.983   |
| **RF**    | 0.935 | 0.941   |

**Вывод** по этому эксперименту (и общий совет): вначале проверяйте на своих данных простые модели – дерево решений и метод ближайших соседей (а в следующий раз сюда добавится логистическая регрессия), может оказаться, что уже они работают достаточно хорошо.

  

### Сложный случай для метода ближайших соседей

Теперь рассмотрим еще один простой пример. В задаче классификации один из признаков будет просто пропорционален вектору ответов, но методу ближайших соседей это не поможет.

  

**Код для генерации шумных данных с паттерном**

```python
def form_noisy_data(n_obj=1000, n_feat=100, random_seed=17):
    np.random.seed(random_seed)
    y = np.random.choice([-1, 1], size=n_obj)
    # первый признак пропорционален целевому
    x1 = 0.3 * y
    # остальные признаки – шум
    x_other = np.random.random(size=[n_obj, n_feat - 1])

    return np.hstack([x1.reshape([n_obj, 1]), x_other]), y

X, y = form_noisy_data()
```

Как обычно, будем смотреть на долю правильных ответов на кросс-валидации и на отложенной выборке. Построим кривые, отражающие зависимость этих величин от параметра `n_neighbors` в методе ближайших соседей. Такие кривые называются кривыми валидации.

Видим, что метод ближайших соседей с евклидовой метрикой не справляется с задачей, даже если варьировать число ближайших соседей в широком диапазоне. Напротив, дерево решений легко "обнаруживает" скрытую зависимость в данных при любом ограничении на максимальную глубину.

  

**Построение кривых валидации для kNN**

```python
from sklearn.model_selection import cross_val_score

cv_scores, holdout_scores = [], []
n_neighb = [1, 2, 3, 5] + list(range(50, 550, 50))

for k in n_neighb:

    knn = KNeighborsClassifier(n_neighbors=k)
    cv_scores.append(np.mean(cross_val_score(knn, X_train, y_train, cv=5)))
    knn.fit(X_train, y_train)
    holdout_scores.append(accuracy_score(y_holdout, knn.predict(X_holdout)))

plt.plot(n_neighb, cv_scores, label='CV')
plt.plot(n_neighb, holdout_scores, label='holdout')
plt.title('Easy task. kNN fails')
plt.legend();
```

![](https://habrastorage.org/r/w1560/files/920/8d1/4ce/9208d14ced8e4ce49a27ffb64838b252.png " ")

**Обучение дерева**

```python
tree = DecisionTreeClassifier(random_state=17, max_depth=1)
tree_cv_score = np.mean(cross_val_score(tree, X_train, y_train, cv=5))
tree.fit(X_train, y_train)
tree_holdout_score = accuracy_score(y_holdout, tree.predict(X_holdout))
print('Decision tree. CV: {}, holdout: {}'.format(tree_cv_score, tree_holdout_score))
```

Decision tree. CV: 1.0, holdout: 1.0

Итак, во втором примере дерево справилось с задачей идеально, а метод ближайших соседей испытал трудности. Впрочем, это минус скорее не метода, а используемой евклидовой метрики: в данном случае она не позволила выявить, что один признак намного лучше остальных.

  

## Плюсы и минусы деревьев решений и метода ближайших соседей

#### Плюсы и минусы деревьев решений

Плюсы:

-   Порождение четких правил классификации, понятных человеку, например, "если возраст < 25 и интерес к мотоциклам, то отказать в кредите". Это свойство называют интерпретируемостью модели;
-   Деревья решений могут легко визуализироваться, то есть может "интерпретироваться" (строгого определения я не видел) как сама модель (дерево), так и прогноз для отдельного взятого тестового объекта (путь в дереве);
-   Быстрые процессы обучения и прогнозирования;
-   Малое число параметров модели;
-   Поддержка и числовых, и категориальных признаков.

Минусы:

-   У порождения четких правил классификации есть и другая сторона: деревья очень чувствительны к шумам во входных данных, вся модель может кардинально измениться, если немного изменится обучающая выборка (например, если убрать один из признаков или добавить несколько объектов), поэтому и правила классификации могут сильно изменяться, что ухудшает интерпретируемость модели;
-   Разделяющая граница, построенная деревом решений, имеет свои ограничения (состоит из гиперплоскостей, перпендикулярных какой-то из координатной оси), и на практике дерево решений по качеству классификации уступает некоторым другим методам;
-   Необходимость отсекать ветви дерева (pruning) или устанавливать минимальное число элементов в листьях дерева или максимальную глубину дерева для борьбы с переобучением. Впрочем, переобучение — проблема всех методов машинного обучения;
-   Нестабильность. Небольшие изменения в данных могут существенно изменять построенное дерево решений. С этой проблемой борются с помощью ансамблей деревьев решений (рассмотрим далее);
-   Проблема поиска оптимального дерева решений (минимального по размеру и способного без ошибок классифицировать выборку) NP-полна, поэтому на практике используются эвристики типа жадного поиска признака с максимальным приростом информации, которые не гарантируют нахождения глобально оптимального дерева;
-   Сложно поддерживаются пропуски в данных. Friedman оценил, что на поддержку пропусков в данных ушло около 50% кода CART (классический алгоритм построения деревьев классификации и регрессии – Classification And Regression Trees, в `sklearn` реализована улучшенная версия именно этого алгоритма);
-   Модель умеет только интерполировать, но не экстраполировать (это же верно и для леса и бустинга на деревьях). То есть дерево решений делает константный прогноз для объектов, находящихся в признаковом пространстве вне параллелепипеда, охватывающего все объекты обучающей выборки. В нашем примере с желтыми и синими шариками это значит, что модель дает одинаковый прогноз для всех шариков с координатой > 19 или < 0.

  

#### Плюсы и минусы метода ближайших соседей

Плюсы:

-   Простая реализация;
-   Неплохо изучен теоретически;
-   Как правило, метод хорош для первого решения задачи, причем не только классификации или регрессии, но и, например, рекомендации;
-   Можно адаптировать под нужную задачу выбором метрики или ядра (в двух словах: ядро может задавать операцию сходства для сложных объектов типа графов, а сам подход kNN остается тем же). Кстати, профессор ВМК МГУ и опытный участник соревнований по анализу данных Александр Дьяконов любит самый простой kNN, но с настроенной метрикой сходства объектов. Можно почитать про некоторые его решения в [этой статье](https://dyakonov.org/2018/06/28/%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%8B%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85/);
-   Неплохая интерпретация, можно объяснить, почему тестовый пример был классифицирован именно так. Хотя этот аргумент можно атаковать: если число соседей большое, то интерпретация ухудшается (условно: "мы не дали ему кредит, потому что он похож на 350 клиентов, из которых 70 – плохие, что на 12% больше, чем в среднем по выборке").

Минусы:

-   Метод считается быстрым в сравнении, например, с композициями алгоритмов, но в реальных задачах, как правило, число соседей, используемых для классификации, будет большим (100-150), и в таком случае алгоритм будет работать не так быстро, как дерево решений;
-   Если в наборе данных много признаков, то трудно подобрать подходящие веса и определить, какие признаки не важны для классификации/регрессии;
-   Зависимость от выбранной метрики расстояния между примерами. Выбор по умолчанию евклидового расстояния чаще всего ничем не обоснован. Можно отыскать хорошее решение перебором параметров, но для большого набора данных это отнимает много времени;
-   Нет теоретических оснований выбора определенного числа соседей — только перебор (впрочем, чаще всего это верно для всех гиперпараметров всех моделей). В случае малого числа соседей метод чувствителен к выбросам, то есть склонен переобучаться;
-   Как правило, плохо работает, когда признаков много, из-за "прояклятия размерности". Про это хорошо рассказывает известный в ML-сообществе профессор Pedro Domingos – [тут](https://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf) в популярной статье "A Few Useful Things to Know about Machine Learning", также "the curse of dimensionality" описывается в книге Deep Learning в [главе](http://www.deeplearningbook.org/contents/ml.html) "Machine Learning basics".

На этом мы подходим к концу, надеемся, этой статьи Вам хватит надолго. К тому же, есть еще и домашнее задание.

  

## Домашнее задание

В качестве закрепления материала предлагаем выполнить [это задание](http://nbviewer.jupyter.org/github/Yorko/mlcourse.ai/blob/main/jupyter_russian/assignments_demo/assignment03_decision_trees.ipynb) – разобраться с тем, как работает дерево решений, на игрушечном примере, затем обучить и настроить деревья в задаче классификации данных Adult репозитория UCI. Проверить себя можно отправив ответы в [веб-форме](https://docs.google.com/forms/d/1bC3jNPH7XZUty_DaIvt0fPrsiS8YFkcpeBKHPSG0hw0) (там же найдете и решение).

Актуальные и обновляемые версии демо-заданий – на английском [на сайте курса](https://mlcourse.ai/). Также по подписке на Patreon (["Bonus Assignments" tier](https://www.patreon.com/ods_mlcourse)) доступны [расширенные домашние задания](https://mlcourse.ai/book/index.html#bonus-assignments) по каждой теме (только на англ.)

  

## Полезные ресурсы

-   Реализация многих алгоритмов машинного обучения с нуля – [репозиторий](https://github.com/rushter/MLAlgorithms) [rushter](https://habr.com/ru/users/rushter/). Полезно, например, посмотреть, как реализованы деревья решений и метод ближайших соседей;
-   [Курс](https://github.com/esokolov/ml-course-hse) Евгения Соколова по машинному обучению (материалы на GitHub). Хорошая теория, нужна неплохая математическая подготовка;
-   [Курс](https://github.com/diefimov) Дмитрия Ефимова на GitHub (англ.). Тоже очень качественные материалы;
-   [Статья](https://habrahabr.ru/post/171759/) "Энтропия и деревья принятия решений" на Хабре;
-   [Статья](https://habrahabr.ru/company/yandex/blog/206058/) "Машинное обучение и анализ данных. Лекция для Малого ШАДа Яндекса" на Хабре.

